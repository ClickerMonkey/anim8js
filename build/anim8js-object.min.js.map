{"version":3,"sources":["anim8js-core.js","anim8js-fast-map.js","anim8js-defer.js","anim8js-easing.js","anim8js-easing-type.js","anim8js-easing-css.js","anim8js-color.js","anim8js-computed.js","anim8js-calculator.js","anim8js-calculator-number.js","anim8js-calculator-2d.js","anim8js-calculator-3d.js","anim8js-calculator-quaternion.js","anim8js-calculator-rgb.js","anim8js-calculator-rgba.js","anim8js-path.js","anim8js-path-tween.js","anim8js-path-cubic.js","anim8js-path-quadratic.js","anim8js-path-delta.js","anim8js-path-jump.js","anim8js-path-compiled.js","anim8js-path-keyframe.js","anim8js-path-point.js","anim8js-attrimator.js","anim8js-attrimator-map.js","anim8js-event.js","anim8js-spring.js","anim8js-spring-linear.js","anim8js-spring-distance.js","anim8js-physics.js","anim8js-animation.js","anim8js-transition.js","anim8js-options.js","anim8js-animator.js","anim8js-animators.js","anim8js-loop.js","anim8js-sequence.js","anim8js-parser.js","anim8js-parser-deltavalues.js","anim8js-parser-final.js","anim8js-parser-initial.js","anim8js-parser-keyframe.js","anim8js-parser-tweenTo.js","anim8js-parser-tweenFrom.js","anim8js-parser-move.js","anim8js-parser-springs.js","anim8js-parser-physics.js","anim8js-parser-travel.js","anim8js-factory.js","anim8js-object.js"],"names":["m8","anim8","subject","Animator","factory","factoryFor","animatorFor","m8s","anim8s","subjects","animators","animatorsFor","Animators","isArray","i","length","animator","push","defaults","duration","easing","teasing","delay","sleep","repeat","scale","transitionTime","transitionOutro","transitionIntro","transitionEasing","transitionGranularity","transitionLookup","cache","cacheOptions","cacheTransitions","noOptions","noTransition","noop","isDefined","x","isFunction","constructor","call","apply","isNumber","isString","Array","isObject","isElement","HTMLElement","nodeType","nodeName","now","Date","getTime","trim","String","prototype","replace","log","size","prop","isEmpty","copy","p","extend","out","arguments","o","override","coalesce","a","b","c","d","time","regex","conversions","ms","cs","jiffy","third","s","sec","m","min","h","hr","returnOnInvalid","Math","floor","parsed","exec","parseFloat","unit","inf","Number","POSITIVE_INFINITY","infinity","infinite","once","twice","thrice","dozen","random","toLowerCase","parseInt","isNaN","number","value","constant","variable","resolve","clamp","v","max","delegate","functionName","returning","RETURN_THIS","this","RETURN_RESULTS","results","RETURN_FIRST","undefined","RETURN_TRUE","eventize","object","onListeners","$this","property","events","callback","context","split","on","offListeners","listeners","event","eventListeners","k","splice","off","$on","$once","triggerListeners","argument","clear","slice","trigger","FastMap","map","reset","putMap","put","values","keys","indices","key","get","remove","removeAt","index","lastValue","pop","lastKey","indexOf","has","hasOverlap","Defer","methods","$factory","$push","$reset","eventable","previous","eventType","$eventable","$previous","$eventType","$event","$callback","$calls","$next","$isRoot","$register","$run","methodName","undefer","defer","next","pair","e","t","easingType","bezier","isEasingName","linear","quad","ease","i2","x2","eq1","eq2","cubic","quartic","quintic","back","x3","sine","sin","overshot","elastic","wave","revisit","abs","lasso","cos","slowbounce","bounce","smallbounce","inv","tinybounce","hesitant","sqrt","sqrtf","log10","slingshot","circular","gentle","mX1","mY1","mX2","mY2","A","aA1","aA2","B","C","CalcBezier","aT","GetSlope","GetTForX","aX","aGuessT","currentSlope","currentX","optional","inout","yoyo","mirror","reverse","flip","cssEase","cssEaseIn","cssEaseOut","cssEaseInOut","cssLinear","color","r","g","parsers","parse","input","parseComponent","parseFunction","vparsed","window","names","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dodgerblue","feldspar","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgrey","lightgreen","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslateblue","lightslategray","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","violetred","wheat","white","whitesmoke","yellow","yellowgreen","named","matches","format","ca","cr","cg","cb","toString","computed","current","attrimator","attr","attribute","getAttribute","frame","calculator","clone","cloneDefault","relative","relativeAmount","mask","isComputed","relativeFunction","calc","mul","add","randomSelection","randomFunction","selected","ZERO","Path","compute","create","resolvedMin","resolvedMax","Calculator","createConstants","ONE","INFINITY","adds","amount","sub","interpolate","start","end","delta","zero","distance","distanceSq","lengthSq","isValid","isZero","isEqual","distSq","isRelative","getRelativeAmount","z","NumberCalculator","defaultValue","amountScale","ab","epsilon","Point2dCalculator","y","cx","cy","rx","ry","ix","iy","aliases","left","right","middle","center","top","bottom","_x","_y","dx","dy","Point3dCalculator","cz","rz","iz","dz","QuaternionCalculator","angle","ra","ia","da","RGBCalculator","rr","rg","rb","ir","ig","ib","dr","dg","db","RGBACalculator","path","spring","type","name","points","hasComputed","ps","reference","trues","last","first","point","replaceComputed","resolvePoint","isLinear","granularity","prev","temp","Tween","CubicPath","p0","p1","p2","p3","d1","d2","d3","i1","i3","QuadraticPath","DeltaPath","deltas","ds","d0","pd","JumpPath","CompiledPath","pointCount","KeyframePath","easings","ea","defaultEasing","PointPath","Attrimator","parser","startTime","pauseTime","elapsed","stopTime","paused","cycle","offset","finished","startCycle","setTime","updated","finish","update","getElapsed","stopIn","milliseconds","valueAt","totalTime","timeRemaining","isInfinite","pause","resume","isPaused","isFinished","getParser","queue","AttrimatorMap","queueMap","onNewAttribute","maxRemaining","attrimators","existing","unqueueAt","remaining","applyCycle","nextCycle","currentDepth","nextDepth","EventState","CREATED","DELAYED","ANIMATING","SLEEPING","PAUSED","FINISHED","Event","scaleBase","hasInitialState","state","applyValue","oldState","newState","iteration","computeValue","baseValue","Spring","set","rest","position","velocity","gravity","finishOnRest","parseValue","dt","MAX_DT","starting","updateVelocity","EPSILON","resolveRest","LinearSpring","damping","stiffness","temp0","temp1","DistanceSpring","Physics","acceleration","terminal","initalPosition","vel","resolveVelocity","acc","resolveAcceleration","pos","usePosition","animation","options","Animation","animationStrings","anim","parsedAnimation","parsedOptions","attrimatorMap","helper","ParserHelper","parserName","save","isSaved","newAttrimators","merge","force","transition","originalInput","transitionArray","part","charAt","intro","substring","outro","lookup","parseProperty","propertyAdd","propertyScale","fn","attrimatorsAdded","active","cycleCurrent","cycleNext","cycleEnded","newCycle","applyCurrentCycle","endCurrentCycle","restore","preupdate","aa","setDefault","wasFinished","minCycle","placeAttrimator","trimAttrimators","activate","deactivate","destroy","createAttrimators","onAnimation","queueAttrimators","play","all","playAttrimators","finishNotPresent","transitionAttrimators","totalDelay","curr","pastLookahead","pastVelocity","pastNegativeVelocity","past","outTime","outPoint","outNext","inTime","inPoint","inNext","outVelocity","outPerMillis","inVelocity","inPerMillis","compiled","lastPoint","totalDistance","distances","requiredTime","timeDelta","transitionEvent","tweenTo","target","tweenManyTo","targets","tween","starts","ends","tweenMany","ref","request","follow","attrimatorsFor","attributes","resulting","stop","unset","hasAttrimators","getSubject","wrapper","invoke","func","args","DeferAnimator","onCycleStart","onCycleEnd","fill","each","iterator","filter","filterer","alive","getSubjects","mid","e0","e1","animating","running","requestRun","run","sequence","Sequence","live","vendors","requestor","requestAnimationFrame","lastTime","timeToCall","currTime","id","setTimeout","maxDelay","delayOffset","Parser","newOptions","oldOptions","mergeEasing","mergeRepeat","mergeDelay","mergeSleep","mergeDuration","mergeScale","mergeScaleBase","prepareSpecifics","specifics","parseEasing","parseFirst","parseRepeat","parseNumber","parseDelay","parseSleep","parseDuration","parseScale","parseScaleBase","option","parseEvent","parseOptionFunction","optionAdd","optionScale","baseRaw","base","mergeFirst","mergeNumber","ParserDeltas","valueCount","deltaObject","ParserFinal","ParserInitial","initial","ParserKeyframe","kframes","keyframe","sort","from","half","to","times","maxTime","order","pathEasings","ParserTweenTo","ParserTweenFrom","tweenFrom","ParserMove","move","ParseSpring","springs","ParsePhysics","physics","physic","stopAt","ParserTravel","travel","pointing","subtractVelocity","pointingFunction","targetValue","difference","traveling","traveler","highestPriorityFactory","factoryName","is","priority","Factory","ObjectFactory","$animator","calculatorName"],"mappings":"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","file":"anim8js-object.min.js","sourcesContent":["\n/**\n * Converts a subject into an animator and returns it. If the subject \n * is already an animator it's returned immediately.\n *\n * @param {any} subject\n */\nm8 = anim8 = function(subject) \n{\n  if ( subject instanceof anim8.Animator )\n  {\n    return subject;\n  }\n\n  var factory = anim8.factoryFor( subject, true );\n\n  if ( factory === false )\n  {\n    return false;\n  }\n\n  return factory.animatorFor( subject );\n};\n\n/**\n * Converts an array of subjects into an array of Animators.\n *\n * @param {array} subject\n */\nm8s = anim8s = function(subjects)\n{\n  var factory = anim8.factoryFor( subjects, true );\n  var animators = [];\n\n  if ( factory !== false )\n  {\n    factory.animatorsFor( subjects, animators );\n\n    return new anim8.Animators( animators );\n  }\n\n  if ( !anim8.isArray( subjects ) )\n  {\n    subjects = [ subjects ];\n  }\n\n  var animators = [];\n\n  for (var i = 0; i < subjects.length; i++)\n  {\n    var animator = anim8( subjects[i] );\n\n    if ( animator !== false )\n    {\n      animators.push( animator );\n    }\n  }\n\n  return new anim8.Animators( animators );\n};\n\n\n/**\n * The default values for event properties.\n */\nanim8.defaults = \n{\n\n  /**\n   * The default animation duration in milliseconds.\n   * \n   * @type {number}\n   */\n  duration: 1000,\n\n  /**\n   * The default easing.\n   * \n   * @type {string|function}\n   */\n  easing: 'ease',\n\n  /**\n   * The default \"total easing\" which is the overall easing\n   * for an animation which actually has easing values per frame.\n   * \n   * @type {string|function}\n   */\n  teasing: 'linear',\n\n  /**\n   * The default animation delay in milliseconds.\n   * \n   * @type {number}\n   */\n  delay: 0,\n\n  /**\n   * The default animation sleep in milliseconds.\n   * \n   * @type {number}\n   */\n  sleep: 0,\n\n  /**\n   * The default number of repeats for an animation.\n   * \n   * @type {number}\n   */\n  repeat: 1,\n\n  /**\n   * The default scale for an animation.\n   * \n   * @type {number}\n   */\n  scale: 1.0,\n\n  /**\n   * The default transition time in milliseconds.\n   * \n   * @type {number}\n   */\n  transitionTime: 500,\n\n  /**\n   * The default transition outroduction time in milliseconds.\n   * \n   * @type {number}\n   */\n  transitionOutro: 100,\n\n  /**\n   * The default transition introduction time in milliseconds.\n   * \n   * @type {number}\n   */\n  transitionIntro: 100,\n\n  /**\n   * The default transition easing when none is specified.\n   * \n   * @type {string|function}\n   */\n  transitionEasing: 'linear',\n\n  /**\n   * The default transition granularity. This is used for smooth transitions to\n   * provide a smooth transition from the outro velocity to the intro velocity,\n   * the cubic or quadratic path between the two is a curve with unknown length\n   * so the length needs to be calculated using a maximum number of points to\n   * calculate along the path - summing the distances between the consecutive points.\n   * \n   * @type {Number}\n   */\n  transitionGranularity: 0,\n\n  /**\n   * TODO\n   * \n   * @type {Number}\n   */\n  transitionLookup: 10,\n\n  /**\n   * Whether animtions are cached whenever possible. Animations that can be\n   * cached are strings with options specified in the string and without an\n   * option object given. For example 'tada ~1s 3s x3' is cacheable.\n   * \n   * @type {boolean}\n   * @see  anim8.animation\n   */\n  cache: false,\n\n  /**\n   * Whether parsed options are cached whenever possible. Options that can be\n   * cached must be strings.\n   * \n   * @type {Boolean}\n   * @see  anim8.options\n   */\n  cacheOptions: false,\n\n  /**\n   * Whether parsed transitions are cached whenever possible. Transitions that can be\n   * cached must be strings.\n   * \n   * @type {Boolean}\n   * @see  anim8.transition\n   */\n  cacheTransitions: false,\n\n  /**\n   * The value to return when options could not be parsed from input.\n   * \n   * @type {Object}\n   */\n  noOptions: {},\n\n  /**\n   * The value to return when a transition could not be parsed from input.\n   * @type {Object}\n   */\n  noTransition: {}\n\n};\n\n/*****************************************************************\n  UTILITY FUNCTIONS\n******************************************************************/\n\n/**\n * A function that does nothing.\n */\nanim8.noop = function() {};\n\n/**\n * Returns true if the given variable is defined.\n */\nanim8.isDefined = function(x) \n{\n  return typeof x !== 'undefined';\n};\n\n/**\n * Returns true if the given variable is a function.\n */\nanim8.isFunction = function(x) \n{\n  return !!(x && x.constructor && x.call && x.apply);\n};\n\n/**\n * Returns true if the given variable is a number.\n */\nanim8.isNumber = function(x) \n{\n  return typeof x === 'number';\n};\n\n/**\n * Returns true if the given variable is a string.\n */\nanim8.isString = function(x) \n{\n  return typeof x === 'string';\n};\n\n/**\n * Returns true if the given variable is an array. This should be checked before\n * anim8.isObject since Arrays are objects.\n */\nanim8.isArray = function(x) \n{\n  return x instanceof Array;\n};\n\n/**\n * Returns true if the given variable is an object.\n */\nanim8.isObject = function(x) \n{\n  return typeof x === 'object';\n};\n\n/**\n * Returns true if the given variable is an HTML element.\n */\nanim8.isElement = function(x)\n{\n  return typeof HTMLElement === \"object\" ? x instanceof HTMLElement :\n  x && typeof x === \"object\" && x !== null && x.nodeType === 1 && typeof x.nodeName === \"string\";\n};\n\n/**\n * Returns the current time in milliseconds.\n */\nanim8.now = (function() {\n\n  return Date.now ? Date.now : function() \n  {\n    return new Date().getTime();\n  };\n  \n})();\n\n/**\n * [description]\n * @param  {[type]}\n * @return {[type]}\n */\nanim8.trim = (function()\n{ \n  if (String.prototype.trim) {\n    return function(x) {\n      return x.trim();\n    };\n  }\n  return function(x) {\n    return x.replace(/^([\\s]*)|([\\s]*)$/g, '');\n  };\n})();\n\n/**\n * If the user is interested in seeing warnings they can override this by specifying\n * a function which accepts a text argument providing a generc message, a second argument\n * which has the input that caused the warning, and a third agument with the object\n * throwing the warning. Most warnings that are thrown occur when an animation is\n * trying to be parsed an the user provided an invalid animation, time, easing, etc.\n *\n * @param {string} message\n * @param {any} source\n */\nanim8.log = false;\n\n/**\n * Returns the size of the variable. The size of a variable is dependent on the variable\n * type. For arrays and strings their length is returned. If it's an object the number of\n * enumerable properties is returned. If it's a number, the number is returned. Otherwise\n * zero is returned.\n *\n * @param {any} x\n */\n anim8.size = function(x)\n {\n  if ( anim8.isArray( x ) || anim8.isString( x ) )\n  {\n    return x.length;\n  }\n  else if ( x === null )\n  {\n    return 0;\n  }\n  else if ( anim8.isObject( x ) )\n  {\n    var size = 0;\n\n    for (var prop in x)\n    {\n      size++;\n    }\n\n    return size;\n  }\n  else if ( anim8.isNumber( x ) )\n  {\n    return x;\n  }\n\n  return 0;\n};\n\n/**\n * Determines whether the given variable is empty.\n *\n * @param {any} x\n */\nanim8.isEmpty = function(x)\n{\n  if ( anim8.isArray( x ) || anim8.isString( x ) )\n  {\n    return x.length > 0;\n  }\n  else if ( x === null )\n  {\n    return true;\n  }\n  else if ( anim8.isObject( x ) )\n  {\n    for (var prop in x)\n    {\n      return false;\n    }\n  }\n  else if ( anim8.isNumber( x ) )\n  {\n    return x !== 0.0;\n  }\n\n  return true;\n};\n\n/**\n * Performs a deep copy of the given variable. If the variable is an array or object a new instance\n * of that type is created where the values are copied as well. All other types can't be copied\n * (most likely because they're scalar) so they are returned as-is.\n *\n * @param {any} x\n */\nanim8.copy = function(x) \n{\n  if ( anim8.isArray(x) ) \n  {\n    var copy = [];\n    for (var i = 0; i < x.length; i++) \n    {\n      copy.push( anim8.copy( x[i] ) );\n    }\n    x = copy;\n  }\n  else if ( anim8.isObject(x) ) \n  {\n    var copy = {};\n    for (var p in x) \n    {\n      copy[p] = anim8.copy( x[p] );\n    }\n    x = copy;\n  }\n  \n  return x;\n};\n\n/**\n * Extends the given object by merging the following objects into it, avoiding overriding any existing properties.\n * \n * @param  {object} out\n * @return {object}\n */\nanim8.extend = function(out)\n{\n  for (var i = 1; i < arguments.length; i++)\n  {\n    var o = arguments[ i ];\n\n    if ( anim8.isObject( o ) )\n    {\n      for (var prop in o)\n      {\n        if ( !(prop in out) )\n        {\n          out[prop] = o[prop];\n        }\n      }\n    }\n  }\n\n  return out;\n};\n\n/**\n * Extends the given object my merging the following objects into, overriding existing properties where necessary.\n * \n * @param  {object}\n * @return {object}\n */\nanim8.override = function(out)\n{\n  for (var i = 1; i < arguments.length; i++)\n  {\n    var o = arguments[ i ];\n\n    if ( anim8.isObject( o ) )\n    {\n      for (var prop in o)\n      {\n        out[prop] = o[prop];\n      }\n    }\n  }\n\n  return out;\n};\n\n/**\n * Returns the first defined variable of a possible 4 variables.\n */\nanim8.coalesce = function(a, b, c, d) \n{\n  if (anim8.isDefined(a)) return a;\n  if (anim8.isDefined(b)) return b;\n  if (anim8.isDefined(c)) return c;\n  return d;\n};\n\n/**\n * Parses milliseconds from a string or number. If a number is given it's assumed to be milliseconds\n * and is returned immediately.\n *\n * @param {string|number} time\n * @param [any] returnOnInvalid\n */\nanim8.time = (function()\n{\n  var regex = /^(-?\\d*(\\.\\d+)|-?\\d+)(ms|s|c|cs|third|jiffy|sec|m|min|h|hr)?$/;\n  \n  var conversions = {\n    ms:     1,\n    c:      100,\n    cs:     100,\n    jiffy:  1000 / 60,\n    third:  1000 / 60,\n    s:      1000,\n    sec:    1000,\n    m:      1000 * 60,\n    min:    1000 * 60,\n    h:      1000 * 60 * 60,\n    hr:     1000 * 60 * 60\n  };\n  \n  return function(time, returnOnInvalid) \n  {  \n    if ( anim8.isNumber( time ) )\n    {\n      // raw numbers are considered milliseconds\n      return Math.floor( time );\n    }\n    if ( anim8.isString( time ) )\n    {\n      var parsed = regex.exec( time );\n      \n      if ( parsed )\n      {\n        var time = parseFloat( parsed[1] );\n        var unit = parsed[3];\n        \n        if ( unit in conversions )\n        {\n          time *= conversions[ unit ];\n        }\n        \n        return Math.floor( time );\n      }\n    }\n    \n    return anim8.coalesce( returnOnInvalid, 0 );\n  };\n  \n})();\n\n/**\n * Parses delay from a string or number.\n *\n * @param {string|number}\n * @see anim8.time\n */ \nanim8.delay = function(time)\n{\n  return anim8.time( time, anim8.defaults.delay );\n};\n\n/**\n * Parses sleep from a string or number.\n *\n * @param {string|number}\n * @see anim8.time\n */ \nanim8.sleep = function(time)\n{\n  return anim8.time( time, anim8.defaults.sleep );\n};\n\n/**\n * Parses duration from a string or number.\n *\n * @param {string|number}\n * @see anim8.time\n */ \nanim8.duration = function(time)\n{\n  return anim8.time( time, anim8.defaults.duration );\n};\n\n/**\n * Parses repeats from a string or number.\n *\n * @param {string|number}\n * @param [any] returnOnInvalid\n */\nanim8.repeat = (function() \n{\n  var conversions = {\n    inf:        Number.POSITIVE_INFINITY,\n    infinity:   Number.POSITIVE_INFINITY,\n    infinite:   Number.POSITIVE_INFINITY,\n    once:       1,\n    twice:      2,\n    thrice:     3,\n    dozen:      12,\n    random:     4 // chosen by fair dice roll. guaranteed to be random.\n  };\n\n  return function(repeat, returnOnInvalid)\n  {\n    if ( anim8.isNumber( repeat ) )\n    {\n      return repeat;\n    }\n    if ( anim8.isString( repeat ) )\n    {\n      repeat = repeat.toLowerCase();\n\n      if ( repeat in conversions )\n      {\n        return conversions[ repeat ];\n      }\n      else\n      {\n        var parsed = parseInt( repeat );\n\n        if ( !isNaN(parsed) )\n        {\n          return parsed;\n        }\n      }\n    }\n\n    return anim8.coalesce( returnOnInvalid, anim8.defaults.repeat );\n  };\n\n})();\n\n/**\n * Parses a number from the given input and if the input isn't a valid number\n * then returnOnInvalid is returned.\n * \n * @param  {any} value\n * @param  {any} returnOnInvalid\n * @return {any}\n */\nanim8.number = function(value, returnOnInvalid)\n{\n  var parsed = parseFloat( value );\n\n  return isNaN( parsed ) ? returnOnInvalid : parsed;\n};\n\n/**\n * Parses scale from a string or number.\n * \n * @param  {string|number}\n * @return {number}\n */\nanim8.scale = function(scale, returnOnInvalid)\n{\n  return anim8.number( scale, anim8.defaults.scale );\n};\n\n/**\n * Provides a way to wrap a variable so calculators don't try copying it on parse.\n *\n * @param {any} variable\n */\nanim8.constant = function(variable)\n{\n  return function() \n  {\n    return variable;\n  };\n};\n\n/**\n * Resolves the given variable. If the variable is a function the result is returned.\n * \n * @param  {any}\n * @return {any}\n */\nanim8.resolve = function(variable)\n{\n  return anim8.isFunction( variable ) ? variable() : variable;\n};\n\n/**\n * Returns a value between the given minimum and maximum.\n * \n * @param  {number} v\n * @param  {number} min\n * @param  {number} max\n * @return {number}\n */\nanim8.clamp = function(v, min, max)\n{\n  return (v < min) ? min : (v > max ? max : v);\n};\n\n/**\n * Creates a function which calls a method on all elements in the array or on the first element.\n *\n * @param {string} functionName\n * @param {string} returning\n */\nanim8.delegate = function(functionName, returning) \n{  \n  switch (returning)\n  {\n  case anim8.delegate.RETURN_THIS:\n    return function() \n    {\n      for (var i = 0; i < this.length; i++) \n      {\n        this[i][functionName].apply( this[i], arguments );\n      }\n      \n      return this;  \n    };\n    \n  case anim8.delegate.RETURN_RESULTS:\n    return function() \n    {\n      var results = [];\n    \n      for (var i = 0; i < this.length; i++) \n      {\n        results.push( this[i][functionName].apply( this[i], arguments ) );\n      }\n    \n      return results;\n    };\n    \n  case anim8.delegate.RETURN_FIRST:\n    return function()\n    {\n      return this.length === 0 ? undefined : this[0][functionName].apply( this[0], arguments );\n    };\n\n  case anim8.delegate.RETURN_TRUE:\n    return function()\n    {\n      for (var i = 0; i < this.length; i++)\n      {\n        if ( this[i][functionName].apply( this[i], arguments ) )\n        {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n  }\n  \n  return anim8.noop;\n};\n\n/**\n * this is returned at the end.\n */\nanim8.delegate.RETURN_THIS = 'this';\n\n/**\n * An array of results for each method call is returned.\n */\nanim8.delegate.RETURN_RESULTS = 'results';\n\n/**\n * The result of the first element.\n */\nanim8.delegate.RETURN_FIRST = 'first';\n\n/**\n * True if any of the methods return true, otherwise false.\n */\nanim8.delegate.RETURN_TRUE = 'true';\n\n\n/**\n * Adds functions to the given object (or prototype) so you can listen for any number of events\n * on the given object, optionally once. Listeners can be removed later.\n */\nanim8.eventize = function(object)\n{\n  var onListeners = function($this, property, events, callback, context)\n  {\n    events = events.split(' ');\n    \n    if ( !anim8.isDefined( $this[ property ] ) )\n    {\n      $this[ property ] = {};\n    }\n    \n    for (var i = 0; i < events.length; i++)\n    {\n      if ( !anim8.isDefined( $this[ property ][ events[i] ] ) )\n      {\n        $this[ property ][ events[i] ] = [];\n      }\n      \n      $this[ property ][ events[i] ].push( [ callback, context || $this ] );\n    }\n  };\n  \n  object.on = function(events, callback, context)\n  {\n    onListeners( this, '$on', events, callback, context );\n  };\n  \n  object.once = function(events, callback, context)\n  {\n    onListeners( this, '$once', events, callback, context );\n  };\n  \n  var offListeners = function(listeners, event, callback)\n  {\n    if (listeners && event in listeners)\n    {\n      var eventListeners = listeners[ event ];\n      \n      for (var k = eventListeners.length - 1; k >= 0; k--)\n      {\n        if (eventListeners[ k ][0] === callback)\n        {\n          eventListeners.splice( k, 1 );\n        }\n      }  \n    }\n  };\n  \n  object.off = function(events, callback)\n  {\n    events = events.split(' ');\n    \n    for (var i = 0; i < events.length; i++)\n    {\n      offListeners( this.$on, events[i] );\n      offListeners( this.$once, events[i] );\n    }\n  };\n  \n  var triggerListeners = function(listeners, event, argument, clear)\n  {\n    if (listeners && event in listeners)\n    {\n      var eventListeners = listeners[ event ];\n\t\t\tvar max = eventListeners.length;\n     \n      for (var i = 0; i < max; i++)\n      {\n        var callback = eventListeners[ i ];\n        \n        callback[0].call( callback[1], argument );\n      }\n      \n      if ( clear )\n      {\n\t\t\t\tif ( eventListeners.length !== max )\n\t\t\t\t{\n\t\t\t\t\tlisteners[ event ] = eventListeners.slice( max );\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n          delete listeners[ event ];\t\n\t\t\t\t}\n      }\n\t\t}\n  };\n  \n  object.trigger = function(event, argument)\n  {\n    triggerListeners( this.$on, event, argument, false );\n    triggerListeners( this.$once, event, argument, true );\n  };\n};\n\n","\n/**\n * A FastMap has the key-to-value benefits of a map and iteration benefits of an array.\n * This is especially beneficial when most of the time the contents of the structure need to be iterated and order\n * doesn't matter (since removal performs a swap which breaks insertion order).\n */\nanim8.FastMap = function(map)\n{\n  this.reset();\n\n  if ( map instanceof anim8.FastMap )\n  {\n    this.putMap( map );\n  }\n  else if ( anim8.isObject( map ) )\n  {\n    for (var prop in map)\n    {\n      this.put( prop, map[ prop ] );\n    }\n  }\n};\n\nanim8.FastMap.prototype =\n{\n\n  /**\n   * Resets the map by initializing the values, keys, and indexes.\n   * \n   * @return {this}\n   */\n  reset: function()\n  {\n    this.values = [];\n    this.keys = [];\n    this.indices = {};\n\n    return this;\n  },\n\n  /**\n   * Puts the value in the map by the given key.\n   * \n   * @param  {string} key\n   * @param  {any} value\n   * @return {this}\n   */\n  put: function(key, value)\n  {\n    if ( key in this.indices )\n    {\n      this.values[ this.indices[ key ] ] = value;\n    }\n    else\n    {\n      this.indices[ key ] = this.values.length;\n      this.values.push( value );\n      this.keys.push( key );\n    }\n\n    return this;\n  },\n\n  /**\n   * Puts all keys & values on the given map into this map overwriting any existing values mapped by similar keys.\n   * \n   * @param  {anim8.FastMap}\n   * @return {this}\n   */\n  putMap: function(map)\n  {\n    var keys = map.keys;\n    var values = map.values;\n\n    for (var i = 0; i < keys.length; i++)\n    {\n      this.put( keys[ i ], values[ i ] );\n    }\n\n    return this;\n  },\n\n  /**\n   * Returns the value mapped by the given key.\n   * \n   * @param  {string} key\n   * @return {any}\n   */\n  get: function(key)\n  {\n    return this.values[ this.indices[ key ] ];\n  },\n\n  /**\n   * Removes the value by a given key\n   * \n   * @param  {string} key\n   * @return {this}\n   */\n  remove: function(key)\n  {\n    if ( key in this.indices )\n    {\n      this.removeAt( this.indices[ key ] );\n    }\n\n    return this;\n  },\n\n  /**\n   * Removes the value & key at the given index.\n   * \n   * @param  {Number}\n   * @return {this}\n   */\n  removeAt: function(index)\n  {\n    var key = this.keys[ index ];\n    var lastValue = this.values.pop();\n    var lastKey = this.keys.pop();\n\n    if ( index < this.values.length )\n    {\n      this.values[ index ] = lastValue;\n      this.keys[ index ] = lastKey;\n      this.indices[ lastKey ] = index;\n    }\n\n    delete this.indices[ key ];\n\n    return this;\n  },\n\n  /**\n   * Returns the index of the value in the array given a key.\n   * \n   * @param  {string} key\n   * @return {number}\n   */\n  indexOf: function(key)\n  {\n    return anim8.coalesce( this.indices[ key ], -1 );\n  },\n\n  /**\n   * Returns whether this map has a value for the given key.\n   * \n   * @param  {string}\n   * @return {Boolean}\n   */\n  has: function(key)\n  {\n    return key in this.indices;\n  },\n\n  /**\n   * Returns whether the given input has overlap with keys in this map.\n   * \n   * @param  {anim8.FastMap|object}\n   * @return {Boolean}\n   */\n  hasOverlap: function(map)\n  {\n    var keys = this.keys;\n    var indices = map.indices;\n\n    for (var i = 0; i < keys.length; i++)\n    {\n      if ( keys[i] in indices )\n      {\n        return true;\n      }\n    }\n   \n    return false;\n  },\n\n  /**\n   * Returns the number of elements in the map.\n   * \n   * @return {number}\n   */\n  size: function()\n  {\n    return this.values.length;\n  },\n\n  /**\n   * Clears all keys & values from the map.\n   * \n   * @return {this}\n   */\n  clear: function()\n  {\n    this.values.length = 0;\n    this.keys.length = 0;\n    this.indices = {};\n\n    return this;\n  }\n\n};","anim8.Defer = function(factory, methods)\n{\n\tthis.$factory = factory;\n\t\n\tfor (var i = 0; i < methods.length; i++)\n\t{\t\n\t\tthis[ methods[i] ] = this.$push( methods[i] );\n\t}\n};\n\nanim8.Defer.prototype = \n{\t\n\t$reset: function(eventable, previous, eventType, event, callback)\n\t{\n\t\tthis.$eventable = eventable;\n\t\tthis.$previous = previous;\n\t\tthis.$eventType = eventType;\n\t\tthis.$event = event;\n    this.$callback = callback;\n\t\tthis.$calls = [];\n\t\tthis.$next = [];\n\t\t\n\t\tif ( this.$isRoot() )\n\t\t{\n\t\t\tthis.$register();\n\t\t}\n\t},\n\t$isRoot: function()\n\t{\n\t\treturn this.$eventable === this.$previous;\n\t},\n\t$register: function()\n\t{\n\t\tthis.$eventable[ this.$eventType ]( this.$event, this.$run, this );\n\t},\n\t$push: function(methodName)\n\t{\n\t\treturn function() \n\t\t{\n\t\t\tthis.$calls.push( [methodName, arguments] );\n\t\t\t\n\t\t\treturn this;\n\t\t};\n\t},\n\t$run: function() \n\t{\n    if ( anim8.isFunction( this.$callback ) )\n    {\n      this.$callback.call( this.$eventable, this );\n    }\n    \n\t\tfor (var i = 0; i < this.$calls.length; i++)\n\t\t{\n\t\t\tvar call = this.$calls[ i ];\n\t\t\t\n\t\t\tthis.$eventable[ call[0] ].apply( this.$eventable, call[1] );\n\t\t}\n\t\t\n\t\tfor (var k = 0; k < this.$next.length; k++)\n\t\t{\n\t\t\tthis.$next[ k ].$register();\n\t\t}\n\t},\n\tundefer: function()\n\t{\n\t\treturn this.$previous;\n\t},\n\tdefer: function(eventType, event, callback)\n\t{\n\t\tvar next = new this.$factory( this.$eventable, this, eventType, event, callback );\n\t\t\n\t\tthis.$next.push( next );\n\t\t\n\t\treturn next;\n\t}\n};","\n/**\n * Returns an easing based on the given input. If the input is a function it's assumed to be an easing function and is\n * returned immediately. If the input is a string the easing with that name is returned. If the input is a string in the\n * format 'easing-easingType' then an easing is returned that is a combination of the easing with the given name and the\n * easingType with the given name. If the given input is an array with 4 elements it's assumed to be a bezier path and\n * one is created and returned. If no input is given the default easing is returned. If an easing cannot be determined\n * then an error is thrown.\n * \n * @param {function|string|array} easing\n */\nanim8.easing = function(easing, returnOnInvalid) \n{\n  if ( anim8.isFunction( easing ) ) \n\t{\n    return easing;\n  }\n\tif ( anim8.isString( easing ) )\n\t{\n\t\tif ( easing in anim8.easing )\n\t\t{\n\t\t\treturn anim8.easing[ easing ];\n\t\t}\n    \n\t\tif ( easing.indexOf('-') !== -1 )\n\t\t{\n\t\t\tvar pair = easing.split('-');\n\t\t\tvar e = pair[0];\n\t\t\tvar t = pair[1];\n\t\t\t\n\t\t\tif ( pair.length >= 2 && e in anim8.easing && t in anim8.easingType )\n\t\t\t{\t\t\t\t\n\t\t\t\treturn anim8.easingType[ t ]( anim8.easing[ e ] );\n\t\t\t}\n\t\t}\n\t}\n  if ( anim8.isArray( easing ) && easing.length === 4 && anim8.isNumber( easing[0] ) && anim8.isNumber( easing[1] ) && anim8.isNumber( easing[2] ) && anim8.isNumber( easing[3] ) ) \n\t{\n    return anim8.easing.bezier.apply( null, easing );\n  }\n  if ( !anim8.isDefined( easing ) ) \n\t{\n    return anim8.easing.default;\n  }\n\t\n  if ( anim8.isDefined( returnOnInvalid ) )\n  {\n    return returnOnInvalid;\n  }\n  \n  throw easing + ' is not a valid easing';\n};\n\n/**\n * Returns true if the given string would result in returning an easing.\n * \n * @see anim8.easing\n * @param {string} easing\n */\nanim8.isEasingName = function(easing)\n{\n  if ( easing in anim8.easing )\n  {\n    return true;\n  }\n  \n\tvar pair = easing.split('-');\n\tvar e = pair[0];\n\tvar t = pair[1];\n\t\n\tif ( pair.length >= 2 && e in anim8.easing && t in anim8.easingType )\n\t{\t\t\t\t\n    return true;\n\t}\n  \n  return false;\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiJ4IiwiY29sb3IiOiIjMDAwMDAwIn0seyJ0eXBlIjoxMDAwLCJ3aW5kb3ciOlsiLTAuMTkyNTAwMDAwMDAwMDAwMjUiLCIxLjQzMjQ5OTk5OTk5OTk5OTkiLCIwLjAxNzQ5OTk5OTk5OTk5OTg3NyIsIjEuMDE3NDk5OTk5OTk5OTk5OCJdfV0-\n\nanim8.easing.linear = function(x) \n{\n  return x;\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiJ4KngiLCJjb2xvciI6IiMwMDAwMDAifSx7InR5cGUiOjEwMDAsIndpbmRvdyI6WyItMC4xOTI1MDAwMDAwMDAwMDAyNSIsIjEuNDMyNDk5OTk5OTk5OTk5OSIsIjAuMDE3NDk5OTk5OTk5OTk5ODc3IiwiMS4wMTc0OTk5OTk5OTk5OTk4Il19XQ--\nanim8.easing.quad = function(x)\n{\n  return x * x;\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIoKDAuMyooMS14KSooMS14KSp4KSsoMy4wKigxLXgpKngqeCkrKHgqeCp4KSkqKDEteCkreCooMS0oMS14KSooMS14KSooMS14KSooMS14KSkiLCJjb2xvciI6IiMwMDAwMDAifSx7InR5cGUiOjEwMDAsIndpbmRvdyI6WyItMC4xOTI1MDAwMDAwMDAwMDAyNSIsIjEuNDMyNDk5OTk5OTk5OTk5OSIsIjAuMDE3NDk5OTk5OTk5OTk5ODc3IiwiMS4wMTc0OTk5OTk5OTk5OTk4Il19XQ--\nanim8.easing.ease = function(x)\n{\n  var i = (1.0 - x);\n  var i2 = i * i;\n  var x2 = x * x;\n  var eq1 = (0.3 * i2 * x) + (3.0 * i * x2) + (x2 * x);\n  var eq2 = 1.0 - i2 * i2;\n  \n  return eq1 * i + eq2 * x;\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiJ4KngqeCIsImNvbG9yIjoiIzAwMDAwMCJ9LHsidHlwZSI6MTAwMCwid2luZG93IjpbIi0wLjE5MjUwMDAwMDAwMDAwMDI1IiwiMS40MzI0OTk5OTk5OTk5OTk5IiwiMC4wMTc0OTk5OTk5OTk5OTk4NzciLCIxLjAxNzQ5OTk5OTk5OTk5OTgiXX1d\nanim8.easing.cubic = function(x) \n{\n  return x * x * x;\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiJ4KngqeCp4IiwiY29sb3IiOiIjMDAwMDAwIn0seyJ0eXBlIjoxMDAwLCJ3aW5kb3ciOlsiLTAuMTkyNTAwMDAwMDAwMDAwMjUiLCIxLjQzMjQ5OTk5OTk5OTk5OTkiLCIwLjAxNzQ5OTk5OTk5OTk5OTg3NyIsIjEuMDE3NDk5OTk5OTk5OTk5OCJdfV0-\nanim8.easing.quartic = function(x) \n{\n  var x2 = x * x;\n  return x2 * x2;\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiJ4KngqeCp4KngiLCJjb2xvciI6IiMwMDAwMDAifSx7InR5cGUiOjEwMDAsIndpbmRvdyI6WyItMC4xOTI1MDAwMDAwMDAwMDAyNSIsIjEuNDMyNDk5OTk5OTk5OTk5OSIsIjAuMDE3NDk5OTk5OTk5OTk5ODc3IiwiMS4wMTc0OTk5OTk5OTk5OTk4Il19XQ--\nanim8.easing.quintic = function(x) \n{\n  var x2 = x * x;\n  return x2 * x2 * x;\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIoeCp4KngpKyh4KngpLXgiLCJjb2xvciI6IiMwMDAwMDAifSx7InR5cGUiOjEwMDAsIndpbmRvdyI6WyItMC4xOTI1MDAwMDAwMDAwMDAyNSIsIjEuNDMyNDk5OTk5OTk5OTk5OSIsIjAuMDE3NDk5OTk5OTk5OTk5ODc3IiwiMS4wMTc0OTk5OTk5OTk5OTk4Il19XQ--\nanim8.easing.back = function(x) \n{\n  var x2 = x * x;\n\tvar x3 = x2 * x;\n\treturn x3 + x2 - x;\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiJzaW4oeCoxLjU3MDc5NjMyNjc5KSIsImNvbG9yIjoiIzAwMDAwMCJ9LHsidHlwZSI6MTAwMCwid2luZG93IjpbIi0wLjE5MjUwMDAwMDAwMDAwMDI1IiwiMS40MzI0OTk5OTk5OTk5OTk5IiwiMC4wMTc0OTk5OTk5OTk5OTk4NzciLCIxLjAxNzQ5OTk5OTk5OTk5OTgiXX1d\nanim8.easing.sine = function(x) \n{\n\treturn Math.sin( x * 1.57079632679 );\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIoMS4wLXgqKDcuMC8xMCkpKngqKDEwLjAvMy4wKSIsImNvbG9yIjoiIzAwMDAwMCJ9LHsidHlwZSI6MTAwMCwid2luZG93IjpbIi0wLjE5MjUwMDAwMDAwMDAwMDI1IiwiMS40MzI0OTk5OTk5OTk5OTk5IiwiMC4wMTc0OTk5OTk5OTk5OTk4NzciLCIxLjAxNzQ5OTk5OTk5OTk5OTgiXX1d\nanim8.easing.overshot = function(x)\n{\n  return (1.0 - x * (7.0 / 10)) * x * (10.0 / 3.0);\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIoeCp4KigoMi4wKngqeCp4KSt4KngtKDQuMCp4KSsyLjApKSotc2luKHgqMTAuOTk1NTc0Mjg3NikiLCJjb2xvciI6IiMwMDAwMDAifSx7InR5cGUiOjEwMDAsIndpbmRvdyI6WyItMC4xOTI1MDAwMDAwMDAwMDAyNSIsIjEuNDMyNDk5OTk5OTk5OTk5OSIsIjAuMDE3NDk5OTk5OTk5OTk5ODc3IiwiMS4wMTc0OTk5OTk5OTk5OTk4Il19XQ--\nanim8.easing.elastic = function(x) \n{\n  var x2 = x * x;\n  var x3 = x2 * x;\n  var scale = x2 * ((2.0 * x3) + x2 - (4.0 * x) + 2.0);\n\tvar wave = -Math.sin(x * 10.9955742876);\n\treturn scale * wave;\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiJhYnMoeC1zaW4oeCozLjE0MTU5MjY1MzU5KSkiLCJjb2xvciI6IiMwMDAwMDAifSx7InR5cGUiOjEwMDAsIndpbmRvdyI6WyItMC4xOTI1MDAwMDAwMDAwMDAyNSIsIjEuNDMyNDk5OTk5OTk5OTk5OSIsIjAuMDE3NDk5OTk5OTk5OTk5ODc3IiwiMS4wMTc0OTk5OTk5OTk5OTk4Il19XQ--\nanim8.easing.revisit = function(x) \n{\n  return Math.abs( x - Math.sin(x * 3.14159265359) );\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIoMS4wLWNvcyh4KngqeCozNi4wKSooMS4wLXgpKSIsImNvbG9yIjoiIzAwMDAwMCJ9LHsidHlwZSI6MTAwMCwid2luZG93IjpbIi0wLjE5MjUwMDAwMDAwMDAwMDI1IiwiMS40MzI0OTk5OTk5OTk5OTk5IiwiMC4wMTc0OTk5OTk5OTk5OTk4NzciLCIxLjAxNzQ5OTk5OTk5OTk5OTgiXX1d\nanim8.easing.lasso = function(x)\n{\n  return (1.0 - Math.cos(x * x * x * 36.0) * (1.0 - x));\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIoMS4wLWFicygoMS4wLXgqeCkqY29zKHgqeCp4KjE0LjgwNDQwNjYwMTYpKSkiLCJjb2xvciI6IiMwMDAwMDAifSx7InR5cGUiOjEwMDAsIndpbmRvdyI6WyItMC4xOTI1MDAwMDAwMDAwMDAyNSIsIjEuNDMyNDk5OTk5OTk5OTk5OSIsIjAuMDE3NDk5OTk5OTk5OTk5ODc3IiwiMS4wMTc0OTk5OTk5OTk5OTk4Il19XQ--\nanim8.easing.slowbounce = function(x) \n{\n  var x2 = x * x;\n  return (1.0 - Math.abs((1.0 - x2) * Math.cos(x2 * x * 14.8044066016)));\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIoMS4wLWFicygoMS4wLXgpKmNvcyh4KngqMTQuODA0NDA2NjAxNikpKSIsImNvbG9yIjoiIzAwMDAwMCJ9LHsidHlwZSI6MTAwMCwid2luZG93IjpbIi0wLjE5MjUwMDAwMDAwMDAwMDI1IiwiMS40MzI0OTk5OTk5OTk5OTk5IiwiMC4wMTc0OTk5OTk5OTk5OTk4NzciLCIxLjAxNzQ5OTk5OTk5OTk5OTgiXX1d\nanim8.easing.bounce = function(x) \n{\n  return (1.0 - Math.abs((1.0 - x) * Math.cos(x * x * 14.8044066016)));\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIoMS4wLWFicygoMS14KSooMS14KSpjb3MoeCp4KjE0LjgwNDQwNjYwMTYpKSkiLCJjb2xvciI6IiMwMDAwMDAifSx7InR5cGUiOjEwMDAsIndpbmRvdyI6WyItMC4xOTI1MDAwMDAwMDAwMDAyNSIsIjEuNDMyNDk5OTk5OTk5OTk5OSIsIjAuMDE3NDk5OTk5OTk5OTk5ODc3IiwiMS4wMTc0OTk5OTk5OTk5OTk4Il19XQ--\nanim8.easing.smallbounce = function(x) \n{\n  var inv = 1.0 - x;\n\treturn (1.0 - Math.abs(inv * inv * Math.cos(x * x * 14.8044066016)));\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIoMS4wLWFicygoMS14KSooMS14KSpjb3MoeCp4KjcpKSkiLCJjb2xvciI6IiMwMDAwMDAifSx7InR5cGUiOjEwMDAsIndpbmRvdyI6WyItMC4xOTI1MDAwMDAwMDAwMDAyNSIsIjEuNDMyNDk5OTk5OTk5OTk5OSIsIjAuMDE3NDk5OTk5OTk5OTk5ODc3IiwiMS4wMTc0OTk5OTk5OTk5OTk4Il19XQ--\nanim8.easing.tinybounce = function(x) \n{\n  var inv = 1.0 - x;\n\treturn (1.0 - Math.abs(inv * inv * Math.cos(x * x * 7.0)));\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIoY29zKHgqeCoxMi4wKSp4KigxLjAteCkreCkiLCJjb2xvciI6IiMwMDAwMDAifSx7InR5cGUiOjEwMDAsIndpbmRvdyI6WyItMC4xOTI1MDAwMDAwMDAwMDAyNSIsIjEuNDMyNDk5OTk5OTk5OTk5OSIsIjAuMDE3NDk5OTk5OTk5OTk5ODc3IiwiMS4wMTc0OTk5OTk5OTk5OTk4Il19XQ--\nanim8.easing.hesitant = function(x) \n{\n\treturn (Math.cos(x * x * 12.0) * x * (1.0 - x) + x);\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiJzcXJ0KHgpIiwiY29sb3IiOiIjMDAwMDAwIn0seyJ0eXBlIjoxMDAwLCJ3aW5kb3ciOlsiLTAuMTkyNTAwMDAwMDAwMDAwMjUiLCIxLjQzMjQ5OTk5OTk5OTk5OTkiLCIwLjAxNzQ5OTk5OTk5OTk5OTg3NyIsIjEuMDE3NDk5OTk5OTk5OTk5OCJdfV0-\nanim8.easing.sqrt = function(x)\n{\n  return Math.sqrt( x );\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIoKDEuMC0oMS14KSooMS14KSooMS14KSooMS14KSkreCkqMC41IiwiY29sb3IiOiIjMDAwMDAwIn0seyJ0eXBlIjoxMDAwLCJ3aW5kb3ciOlsiLTAuMTkyNTAwMDAwMDAwMDAwMjUiLCIxLjQzMjQ5OTk5OTk5OTk5OTkiLCIwLjAxNzQ5OTk5OTk5OTk5OTg3NyIsIjEuMDE3NDk5OTk5OTk5OTk5OCJdfV0-\nanim8.easing.sqrtf = function(x)\n{\n  var i = (1.0 - x);\n  var i2 = i * i;\n  return ((1.0 - i2 * i2) + x) * 0.5;\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIobG9nKHgpKzIuMCkqMC41IiwiY29sb3IiOiIjMDAwMDAwIn0seyJ0eXBlIjoxMDAwLCJ3aW5kb3ciOlsiLTAuMTkyNTAwMDAwMDAwMDAwMjUiLCIxLjQzMjQ5OTk5OTk5OTk5OTkiLCIwLjAxNzQ5OTk5OTk5OTk5OTg3NyIsIjEuMDE3NDk5OTk5OTk5OTk5OCJdfV0-\nanim8.easing.log10 = function(x)\n{\n  return (Math.log10(x + 0.01) + 2.0) * 0.5 / 1.0021606868913213;\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIoeDwwLjc_KHgqLTAuMzU3KTooKCh4LTAuNykqKHgtMC43KSoyNy41LTAuNSkqMC41KSkiLCJjb2xvciI6IiMwMDAwMDAifSx7InR5cGUiOjEwMDAsIndpbmRvdyI6WyItMC4xOTI1MDAwMDAwMDAwMDAyNSIsIjEuNDMyNDk5OTk5OTk5OTk5OSIsIjAuMDE3NDk5OTk5OTk5OTk5ODc3IiwiMS4wMTc0OTk5OTk5OTk5OTk4Il19XQ--\nanim8.easing.slingshot = function(x)\n{\n  if (x < 0.7) {\n\t\treturn (x * -0.357);\n  } else {\n    var d = x - 0.7;\n    return ((d * d * 27.5 - 0.5) * 0.5);\n  }\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIxLXNxcnQoMS14KngpIiwiY29sb3IiOiIjMDAwMDAwIn0seyJ0eXBlIjoxMDAwLCJ3aW5kb3ciOlsiLTAuMTkyNTAwMDAwMDAwMDAwMjUiLCIxLjQzMjQ5OTk5OTk5OTk5OTkiLCIwLjAxNzQ5OTk5OTk5OTk5OTg3NyIsIjEuMDE3NDk5OTk5OTk5OTk5OCJdfV0-\nanim8.easing.circular = function(x)\n{\n  return 1.0 - Math.sqrt( 1 - x * x );\n};\n\n// http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIoMy4wKigxLjAteCkqeCp4KSsoeCp4KngpIiwiY29sb3IiOiIjMDAwMDAwIn0seyJ0eXBlIjoxMDAwLCJ3aW5kb3ciOlsiLTAuMTkyNTAwMDAwMDAwMDAwMjUiLCIxLjQzMjQ5OTk5OTk5OTk5OTkiLCIwLjAxNzQ5OTk5OTk5OTk5OTg3NyIsIjEuMDE3NDk5OTk5OTk5OTk5OCJdfV0-\nanim8.easing.gentle = function(x)\n{\n  return (3.0 * (1.0 - x) * x * x) + (x * x * x);\n};\n\n/**\n * [bezier description]\n * @param  {[type]}\n * @param  {[type]}\n * @param  {[type]}\n * @param  {[type]}\n * @return {[type]}\n */\nanim8.easing.bezier = function(mX1, mY1, mX2, mY2) \n{\n  // https://gist.githubusercontent.com/gre/1926947/raw/KeySpline.js\n  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\n  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\n  function C(aA1)      { return 3.0 * aA1; }\n\n  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n  function CalcBezier(aT, aA1, aA2) {\n    return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;\n  }\n\n  // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n  function GetSlope(aT, aA1, aA2) {\n    return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n  }\n\n  function GetTForX(aX) {\n    // Newton raphson iteration\n    var aGuessT = aX;\n    for (var i = 0; i < 4; ++i) {\n      var currentSlope = GetSlope(aGuessT, mX1, mX2);\n      if (currentSlope == 0.0) return aGuessT;\n      var currentX = CalcBezier(aGuessT, mX1, mX2) - aX;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  }\n  \n  return function(x) {\n    return CalcBezier( GetTForX( x ), mY1, mY2 );\n  };\n};\n\n/**\n * [default description]\n * @type {[type]}\n */\nanim8.easing.default      = anim8.easing.ease;\n","\n/**\n * Returns an easing type based on the input. If the input is a function that function is immediately returned. \n * If the input is a string the easing type with that name is returned. If no easing type could be determined\n * an error is thrown.\n *\n * @param {function|string} easingType\n */\nanim8.easingType = function(easingType, optional)\n{\n\tif ( anim8.isFunction( easingType ) )\n\t{\n\t\treturn easingType;\n\t}\n\tif ( anim8.isString( easingType ) && easingType in anim8.easingType )\n\t{\n\t\treturn anim8.easingType[ easingType ];\n\t}\n  \n  if ( optional )\n  {\n    return false;\n  }\n\t\n\tthrow easingType + ' is not a valid easing type';\n};\n\n\n/**\n * Easing & Easing Type functions\n */\n\n/**\n * Plays the animation forward normally.\n * \n * @param  {function} easing\n * @return {function}\n */\nanim8.easingType.in = function(easing) \n{\n\treturn function(x) \n\t{\n\t\treturn easing( x );\n\t};\n};\n\n/**\n * Plays the animation forward by flipping the easings momentum.\n * \n * @param  {function} easing\n * @return {function}\n */\nanim8.easingType.out = function(easing) \n{\n\treturn function(x) \n\t{\n\t\treturn 1.0 - easing( 1.0 - x );\n\t};\n};\n\n/**\n * Plays the animation forward by flipping the easings momentum halfway.\n * \n * @param  {function} easing\n * @return {function}\n */\nanim8.easingType.inout = function(easing) \n{\n\treturn function(x) \n\t{\n\t  if ( x < 0.5 ) \n\t  {\n\t    return easing( 2.0 * x ) * 0.5;\n\t  } \n\t  else \n\t  {\n\t    return 1.0 - (easing( 2.0 - 2.0 * x ) * 0.5);\n\t  }\n\t};\n};\n\n/**\n * Plays the aninmation forwards with the given easing, and backwards with the same easing momentum.\n * \n * @param  {function} easing\n * @return {function}\n */\nanim8.easingType.yoyo = function(easing) \n{\n\treturn function(x) \n\t{\n\t  if ( x < 0.5 ) \n\t  {\n\t    return easing( 2.0 * x );\n\t  } \n\t  else \n\t  {\n\t    return easing( 2.0 - 2.0 * x );\n\t  }\n\t};\n};\n\n/**\n * Plays the animation forwards with the given easing, and backwards reflecting the easing's momentum.\n * \n * @param  {function} easing\n * @return {function}\n */\nanim8.easingType.mirror = function(easing)\n{\n\treturn function(x)\n\t{\n\t\tif ( x < 0.5 )\n\t\t{\n\t\t\treturn easing( 2.0 * x );\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 1.0 - easing( 2.0 - 2.0 * x );\n\t\t}\n\t};\n};\n\n/**\n * Plays the animation backwards with using the same easing momentum.\n * \n * @param  {function} easing\n * @return {function}\n */\nanim8.easingType.reverse = function(easing)\n{\n\treturn easing( 1.0 - x );\n};\n\n/**\n * Plays the animation backwards by flipping the easing's momentum.\n * \n * @param  {function} easing\n * @return {function}\n */\nanim8.easingType.flip = function(easing)\n{\n\treturn 1.0 - easing( x );\n};\n","\nanim8.easing.cssEase      = anim8.easing.ease;\nanim8.easing.cssEaseIn    = anim8.easing.quad;\nanim8.easing.cssEaseOut   = anim8.easingType.out( anim8.easing.quad );\nanim8.easing.cssEaseInOut = anim8.easingType.inout( anim8.easing.quad );\nanim8.easing.cssLinear    = anim8.easing.linear;\n","\n/**\n * Instantiates a new color given red, green, blue, and white components.\n * If a component is missed it's default value is either 255 (white) or\n * 1.0 (opaque).\n */\nanim8.color = function(r, g, b, a) \n{\n  return {\n    r: anim8.coalesce( r, 255 ),\n    g: anim8.coalesce( g, 255 ),\n    b: anim8.coalesce( b, 255 ),\n    a: anim8.coalesce( a, 1.0 )\n  };\n};\n\n/**\n * The array of parsing methods to execute sequentally until a color is returned.\n */\nanim8.color.parsers = \n[\n  { /* already parsed color */\n    parse: function(input) {\n      if (typeof input === 'object') {\n        var color = {\n          r: this.parseComponent(input.r, 'parseInt', 255),\n          g: this.parseComponent(input.g, 'parseInt', 255),\n          b: this.parseComponent(input.b, 'parseInt', 255),\n          a: this.parseComponent(input.a, 'parseFloat', 1.0)\n        };\n        return color;\n      }\n      return false;\n    },\n    parseComponent: function(c, parseFunction, max) {\n      var t = typeof c;\n      var v = max;\n      if (t === 'string') {\n        var vparsed = window[parseFunction](t, 10);\n        if (!isNaN(vparsed)) {\n          v = vparsed;\n        }\n      }\n      else if (t === 'number') {\n        v = c;\n      }\n      if (v > max) {\n        v = max;\n      }\n      if (v < 0) {\n        v = 0;\n      }\n      return v;\n    }\n  }, \n  { /* colorname */\n    names: {\n      transparent:{r:255,g:256,b:255,a:0.0},\n      aliceblue:{r:240,g:248,b:255,a:1.0},\n      antiquewhite:{r:250,g:235,b:215,a:1.0},\n      aqua:{r:0,g:255,b:255,a:1.0},\n      aquamarine:{r:127,g:255,b:212,a:1.0},\n      azure:{r:240,g:255,b:255,a:1.0},\n      beige:{r:245,g:245,b:220,a:1.0},\n      bisque:{r:255,g:228,b:196,a:1.0},\n      black:{r:0,g:0,b:0,a:1.0},\n      blanchedalmond:{r:255,g:235,b:205,a:1.0},\n      blue:{r:0,g:0,b:255,a:1.0},\n      blueviolet:{r:138,g:43,b:226,a:1.0},\n      brown:{r:165,g:42,b:42,a:1.0},\n      burlywood:{r:222,g:184,b:135,a:1.0},\n      cadetblue:{r:95,g:158,b:160,a:1.0},\n      chartreuse:{r:127,g:255,b:0,a:1.0},\n      chocolate:{r:210,g:105,b:30,a:1.0},\n      coral:{r:255,g:127,b:80,a:1.0},\n      cornflowerblue:{r:100,g:149,b:237,a:1.0},\n      cornsilk:{r:255,g:248,b:220,a:1.0},\n      crimson:{r:220,g:20,b:60,a:1.0},\n      cyan:{r:0,g:255,b:255,a:1.0},\n      darkblue:{r:0,g:0,b:139,a:1.0},\n      darkcyan:{r:0,g:139,b:139,a:1.0},\n      darkgoldenrod:{r:184,g:134,b:11,a:1.0},\n      darkgray:{r:169,g:169,b:169,a:1.0},\n      darkgreen:{r:0,g:100,b:0,a:1.0},\n      darkkhaki:{r:189,g:183,b:107,a:1.0},\n      darkmagenta:{r:139,g:0,b:139,a:1.0},\n      darkolivegreen:{r:85,g:107,b:47,a:1.0},\n      darkorange:{r:255,g:140,b:0,a:1.0},\n      darkorchid:{r:153,g:50,b:204,a:1.0},\n      darkred:{r:139,g:0,b:0,a:1.0},\n      darksalmon:{r:233,g:150,b:122,a:1.0},\n      darkseagreen:{r:143,g:188,b:143,a:1.0},\n      darkslateblue:{r:72,g:61,b:139,a:1.0},\n      darkslategray:{r:47,g:79,b:79,a:1.0},\n      darkturquoise:{r:0,g:206,b:209,a:1.0},\n      darkviolet:{r:148,g:0,b:211,a:1.0},\n      deeppink:{r:255,g:20,b:147,a:1.0},\n      deepskyblue:{r:0,g:191,b:255,a:1.0},\n      dimgray:{r:105,g:105,b:105,a:1.0},\n      dodgerblue:{r:30,g:144,b:255,a:1.0},\n      feldspar:{r:209,g:146,b:117,a:1.0},\n      firebrick:{r:178,g:34,b:34,a:1.0},\n      floralwhite:{r:255,g:250,b:240,a:1.0},\n      forestgreen:{r:34,g:139,b:34,a:1.0},\n      fuchsia:{r:255,g:0,b:255,a:1.0},\n      gainsboro:{r:220,g:220,b:220,a:1.0},\n      ghostwhite:{r:248,g:248,b:255,a:1.0},\n      gold:{r:255,g:215,b:0,a:1.0},\n      goldenrod:{r:218,g:165,b:32,a:1.0},\n      gray:{r:128,g:128,b:128,a:1.0},\n      green:{r:0,g:128,b:0,a:1.0},\n      greenyellow:{r:173,g:255,b:47,a:1.0},\n      honeydew:{r:240,g:255,b:240,a:1.0},\n      hotpink:{r:255,g:105,b:180,a:1.0},\n      indianred:{r:205,g:92,b:92,a:1.0},\n      indigo:{r:75,g:0,b:130,a:1.0},\n      ivory:{r:255,g:255,b:240,a:1.0},\n      khaki:{r:240,g:230,b:140,a:1.0},\n      lavender:{r:230,g:230,b:250,a:1.0},\n      lavenderblush:{r:255,g:240,b:245,a:1.0},\n      lawngreen:{r:124,g:252,b:0,a:1.0},\n      lemonchiffon:{r:255,g:250,b:205,a:1.0},\n      lightblue:{r:173,g:216,b:230,a:1.0},\n      lightcoral:{r:240,g:128,b:128,a:1.0},\n      lightcyan:{r:224,g:255,b:255,a:1.0},\n      lightgoldenrodyellow:{r:250,g:250,b:210,a:1.0},\n      lightgrey:{r:211,g:211,b:211,a:1.0},\n      lightgreen:{r:144,g:238,b:144,a:1.0},\n      lightpink:{r:255,g:182,b:193,a:1.0},\n      lightsalmon:{r:255,g:160,b:122,a:1.0},\n      lightseagreen:{r:32,g:178,b:170,a:1.0},\n      lightskyblue:{r:135,g:206,b:250,a:1.0},\n      lightslateblue:{r:132,g:112,b:255,a:1.0},\n      lightslategray:{r:119,g:136,b:153,a:1.0},\n      lightsteelblue:{r:176,g:196,b:222,a:1.0},\n      lightyellow:{r:255,g:255,b:224,a:1.0},\n      lime:{r:0,g:255,b:0,a:1.0},\n      limegreen:{r:50,g:205,b:50,a:1.0},\n      linen:{r:250,g:240,b:230,a:1.0},\n      magenta:{r:255,g:0,b:255,a:1.0},\n      maroon:{r:128,g:0,b:0,a:1.0},\n      mediumaquamarine:{r:102,g:205,b:170,a:1.0},\n      mediumblue:{r:0,g:0,b:205,a:1.0},\n      mediumorchid:{r:186,g:85,b:211,a:1.0},\n      mediumpurple:{r:147,g:112,b:216,a:1.0},\n      mediumseagreen:{r:60,g:179,b:113,a:1.0},\n      mediumslateblue:{r:123,g:104,b:238,a:1.0},\n      mediumspringgreen:{r:0,g:250,b:154,a:1.0},\n      mediumturquoise:{r:72,g:209,b:204,a:1.0},\n      mediumvioletred:{r:199,g:21,b:133,a:1.0},\n      midnightblue:{r:25,g:25,b:112,a:1.0},\n      mintcream:{r:245,g:255,b:250,a:1.0},\n      mistyrose:{r:255,g:228,b:225,a:1.0},\n      moccasin:{r:255,g:228,b:181,a:1.0},\n      navajowhite:{r:255,g:222,b:173,a:1.0},\n      navy:{r:0,g:0,b:128,a:1.0},\n      oldlace:{r:253,g:245,b:230,a:1.0},\n      olive:{r:128,g:128,b:0,a:1.0},\n      olivedrab:{r:107,g:142,b:35,a:1.0},\n      orange:{r:255,g:165,b:0,a:1.0},\n      orangered:{r:255,g:69,b:0,a:1.0},\n      orchid:{r:218,g:112,b:214,a:1.0},\n      palegoldenrod:{r:238,g:232,b:170,a:1.0},\n      palegreen:{r:152,g:251,b:152,a:1.0},\n      paleturquoise:{r:175,g:238,b:238,a:1.0},\n      palevioletred:{r:216,g:112,b:147,a:1.0},\n      papayawhip:{r:255,g:239,b:213,a:1.0},\n      peachpuff:{r:255,g:218,b:185,a:1.0},\n      peru:{r:205,g:133,b:63,a:1.0},\n      pink:{r:255,g:192,b:203,a:1.0},\n      plum:{r:221,g:160,b:221,a:1.0},\n      powderblue:{r:176,g:224,b:230,a:1.0},\n      purple:{r:128,g:0,b:128,a:1.0},\n      red:{r:255,g:0,b:0,a:1.0},\n      rosybrown:{r:188,g:143,b:143,a:1.0},\n      royalblue:{r:65,g:105,b:225,a:1.0},\n      saddlebrown:{r:139,g:69,b:19,a:1.0},\n      salmon:{r:250,g:128,b:114,a:1.0},\n      sandybrown:{r:244,g:164,b:96,a:1.0},\n      seagreen:{r:46,g:139,b:87,a:1.0},\n      seashell:{r:255,g:245,b:238,a:1.0},\n      sienna:{r:160,g:82,b:45,a:1.0},\n      silver:{r:192,g:192,b:192,a:1.0},\n      skyblue:{r:135,g:206,b:235,a:1.0},\n      slateblue:{r:106,g:90,b:205,a:1.0},\n      slategray:{r:112,g:128,b:144,a:1.0},\n      snow:{r:255,g:250,b:250,a:1.0},\n      springgreen:{r:0,g:255,b:127,a:1.0},\n      steelblue:{r:70,g:130,b:180,a:1.0},\n      tan:{r:210,g:180,b:140,a:1.0},\n      teal:{r:0,g:128,b:128,a:1.0},\n      thistle:{r:216,g:191,b:216,a:1.0},\n      tomato:{r:255,g:99,b:71,a:1.0},\n      turquoise:{r:64,g:224,b:208,a:1.0},\n      violet:{r:238,g:130,b:238,a:1.0},\n      violetred:{r:208,g:32,b:144,a:1.0},\n      wheat:{r:245,g:222,b:179,a:1.0},\n      white:{r:255,g:255,b:255,a:1.0},\n      whitesmoke:{r:245,g:245,b:245,a:1.0},\n      yellow:{r:255,g:255,b:0,a:1.0},\n      yellowgreen:{r:154,g:205,b:50,a:1.0}\n    },\n    parse: function(input) {\n      if (typeof input === 'string') {\n        input = input.toLowerCase();\n        if (input in this.names) {\n          var named = this.names[input];\n          return {\n            r: named.r,\n            g: named.g,\n            b: named.b,\n            a: named.a\n          };\n        }\n      }\n      return false;\n    }\n  },\n  { /* #rgb */\n    regex: /^#?([0-9A-F])([0-9A-F])([0-9A-F])$/i,\n    parse: function(input) {\n      var matches = this.regex.exec(input);\n      if (matches !== null) {\n        return {\n          r: parseInt(matches[1] + matches[1], 16),\n          g: parseInt(matches[2] + matches[2], 16),\n          b: parseInt(matches[3] + matches[3], 16),\n          a: 1.0\n        };\n      }\n      return false;\n    }\n  },\n  { /* #rrggbb */\n    regex: /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i,\n    parse: function(input) {\n      var matches = this.regex.exec(input);\n      if (matches !== null) {\n        return {\n          r: parseInt(matches[1], 16),\n          g: parseInt(matches[2], 16),\n          b: parseInt(matches[3], 16),\n          a: 1.0\n        };\n      }\n      return false;\n    }\n  },\n  { /* RGB(r,g,b) */\n    regex: /^rgb\\(\\s*(\\d{3})\\s*,\\s*(\\d{3})\\s*,\\s*(\\d{3})\\s*\\)$/i,\n    parse: function(input) {\n      var matches = this.regex.exec(input);\n      if (matches !== null) {\n        return {\n          r: Math.min(255, parseInt(matches[1], 10)),\n          g: Math.min(255, parseInt(matches[2], 10)),\n          b: Math.min(255, parseInt(matches[3], 10)),\n          a: 1.0\n        };\n      }\n      return false;\n    }\n  },\n  { /* RGBA(r,g,b,a) */\n    regex: /^rgba\\(\\s*(\\d{3})\\s*,\\s*(\\d{3})\\s*,\\s*(\\d{3})\\s*,\\s*([01]?\\.\\d+|[01])\\)$/i,\n    parse: function(input) {\n      var matches = this.regex.exec(input);\n      if (matches !== null) {\n        return {\n          r: Math.min(255, parseInt(matches[1], 10)),\n          g: Math.min(255, parseInt(matches[2], 10)),\n          b: Math.min(255, parseInt(matches[3], 10)),\n          a: Math.min(1.0, parseFloat(matches[4]))\n        };\n      }\n      return false;\n    }\n  }\n];\n\n/**\n * Parses a color from a string.\n *\n * @param {string} input\n */\nanim8.color.parse = function(input)\n{\n  var cp = m8.color.parsers;\n  \n  for (var i = 0; i < this.parsers.length; i++)\n  {\n    var parsed = this.parsers[i].parse(input);\n    \n    if (parsed !== false) \n    {\n      return parsed;\n    }\n  }\n  \n  return false;\n};\n\n/**\n * Formats a color to a string.\n * \n * @param {object} color\n */\nanim8.color.format = function(color)\n{\n  var ca = anim8.clamp( anim8.coalesce( color.a, 1.0 ), 0, 1 );\n  var cr = Math.floor( anim8.clamp( anim8.coalesce( color.r, 255 ), 0, 255 ) );\n  var cg = Math.floor( anim8.clamp( anim8.coalesce( color.g, 255 ), 0, 255 ) );\n  var cb = Math.floor( anim8.clamp( anim8.coalesce( color.b, 255 ), 0, 255 ) );\n  \n  if (ca === 1.0)\n  { \n    var r = cr.toString( 16 );\n    var g = cg.toString( 16 );\n    var b = cb.toString( 16 );\n    \n    if (r.length == 1) r = '0' + r;\n    if (g.length == 1) g = '0' + g;\n    if (b.length == 1) b = '0' + b;\n    \n    return '#' + r + g + b;\n  }\n  else\n  {\n    return 'rgba(' + cr + ',' + cg + ',' + cb + ',' + ca + ')';\n  }\n};","\n\n/**\n * [computed description]\n * @type {Object}\n */\nanim8.computed = {};\n\n/**\n * Calculates the current value for an animator.\n * \n * @param  {[type]}\n * @param  {[type]}\n * @return {[type]}\n */\nanim8.computed.current = function(attrimator, animator)\n{\n  var attr = attrimator.attribute;\n  var attribute = animator.getAttribute( attr );\n\n  if ( attr in animator.frame )\n  {\n    return attribute.calculator.clone( animator.frame[ attr ] );\n  }\n  else\n  {\n    return attribute.cloneDefault();\n  }\n};\n\n// Marks the function as computed which is a signal to paths & events.\nanim8.computed.current.computed = true;\n\n/**\n * Calculates a value relative to the attribute value currenrtly in the animator.\n * \n * @param  {[type]}\n * @return {[type]}\n */\nanim8.computed.relative = function(relativeAmount, mask)\n{\n  // If the relativeAmount is already a computed value, return it.\n  if ( anim8.isComputed( relativeAmount ) )\n  {\n    return relativeAmount;\n  }\n\n  var relativeFunction = function(attrimator, animator)\n  { \n    var attr = attrimator.attribute;\n    var attribute = animator.getAttribute( attr );\n    var calc = attribute.calculator;\n    var current = null;\n\n    if ( attr in animator.frame )\n    {\n      current = calc.clone( animator.frame[ attr ] );\n    }\n    else\n    {\n      current = attribute.cloneDefault();\n    }\n\n    if ( mask )\n    {\n      current = calc.mul( current, mask );\n    }\n\n    return calc.add( current, relativeAmount );\n  };\n\n  // Marks the function as computed which is a signal to paths & events.\n  relativeFunction.computed = true;\n\n  // Place the input on the function if the user wants to modify it live\n  relativeFunction.relativeAmount = relativeAmount;\n  relativeFunction.mask = mask;\n\n  return relativeFunction;\n};\n\n/**\n * Returns a random value based on the given random selection.\n * \n * 1. If an array is given an item is randomly chosen from that array.\n * 2. If an instance of anim8.Path is given a point is randomly computed and returned.\n * 3. If an object with min & max values is given a random value between them is returned.\n * \n * @param  {any} randomSelection\n * @return {function}\n */\nanim8.computed.random = function(randomSelection)\n{\n  var randomFunction = null;\n\n  if ( anim8.isArray( randomSelection ) )\n  {\n    randomFunction = function(attrimator, animator)\n    {\n      var attr = attrimator.attribute;\n      var attribute = animator.getAttribute( attr );\n      var calc = attribute.calculator;\n      var selected = randomSelection[ Math.floor( Math.random() * randomSelection.length ) ];\n\n      return calc.parse( selected, calc.ZERO );\n    };\n  }\n  else if ( anim8.isObject( randomSelection ) && randomSelection instanceof anim8.Path )\n  {\n    randomFunction = function(attrimator, animator)\n    {\n      var attr = attrimator.attribute;\n      var attribute = animator.getAttribute( attr );\n      var calc = attribute.calculator;\n\n      return randomSelection.compute( calc.create(), Math.random() );\n    };\n  }\n  else if ( anim8.isObject( randomSelection ) && anim8.isDefined( randomSelection.min ) && anim8.isDefined( randomSelection.max ) )\n  {\n    randomFunction = function(attrimator, animator)\n    {\n      var attr = attrimator.attribute;\n      var attribute = animator.getAttribute( attr );\n      var calc = attribute.calculator;\n      var resolvedMin = anim8.resolve( randomSelection.min );\n      var resolvedMax = anim8.resolve( randomSelection.max );\n      var min = calc.parse( resolvedMin, calc.ZERO );\n      var max = calc.parse( resolvedMax, calc.ZERO );\n\n      return calc.random( calc.create(), min, max );\n    };\n  }\n  else\n  {\n    throw 'Invalid random input: ' + randomSelection;\n  }\n\n  // Marks the function as computed which is a signal to paths & events.\n  randomFunction.computed = true;\n\n  // Place the input on the function if the user wants to modify it live\n  randomFunction.randomSelection = randomSelection;\n\n  return randomFunction;\n};\n\n/**\n * [isComputed description]\n * @param  {[type]}\n * @return {Boolean}\n */\nanim8.isComputed = function(x)\n{\n  return anim8.isFunction( x ) && x.computed;\n};","/**\n * Calculators perform math and basic operations for a specific data structure.\n */\n\n/**\n * Returns a calculator based on the input. If the input is an object that object is immediately returned.\n * If the input is a string the calculator with that name is returned. If no calculator could be determined\n * the default calculator is returned.\n *\n * @param {object|string} calc\n */\nanim8.calculator = function(calc)\n{\n  if ( calc instanceof anim8.Calculator )\n  {\n    return calc;\n  }\n\tif ( anim8.isString( calc ) && calc in anim8.calculator )\n\t{\n\t\treturn anim8.calculator[ calc ];\n\t}\n\t\n\treturn anim8.calculator.default;\n};\n\n/**\n * Instantiates a new Calculator instance.\n */\nanim8.Calculator = function()\n{\n\n};\n\nanim8.Calculator.prototype = \n{\n\n  /**\n   * [createConstants description]\n   * @return {[type]}\n   */\n  createConstants: function()\n  {\n    this.ZERO = this.create();\n    this.ONE = this.parse( 1.0, this.ZERO );\n    this.INFINITY = this.parse( Number.POSITIVE_INFINITY, this.ZERO );\n  },\n\n  /**\n   * [parse description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  parse: function(x, defaultValue)\n  {\n    throw 'Calculator.parse not implemented';\n  },\n\n  /**\n   * [copy description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  copy: function(out, copy)\n  {\n    throw 'Calculator.copy not implemented';\n  },\n\n  /**\n   * [clone description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  clone: function(out) \n  {\n    return this.copy( this.create(), out );\n  },\n\n  /**\n   * [create description]\n   * @return {[type]}\n   */\n  create: function()\n  {\n    throw 'Calculator.create not implemented';\n  },\n\n  /**\n   * [scale description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  scale: function(out, scale) \n  {\n    return this.adds( out, out, scale - 1 );\n  },\n\n  /**\n   * [add description]\n   * @param {[type]}\n   * @param {[type]}\n   */\n  add: function(out, amount) \n  {\n    return this.adds( out, amount, 1 );\n  },\n\n  /**\n   * [adds description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  adds: function(out, amount, amountScale)\n  {\n    throw 'Calculator.adds not implemented';\n  },\n\n  /**\n   * [sub description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  sub: function(out, amount) \n  {\n    return this.adds( out, amount, -1 );\n  },\n\n  /**\n   * [mul description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  mul: function(out, scale)\n  {\n    throw 'Calculator.mul not implemented';\n  },\n\n  /**\n   * [interpolate description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  interpolate: function(out, start, end, delta) \n  {\n    out = this.zero( out );\n    out = this.adds( out, start, 1 - delta );\n    out = this.adds( out, end, delta );\n    return out;\n  },\n\n  /**\n   * Returns a random value between the given min and max.\n   * \n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  random: function(out, min, max)\n  {\n    return this.interpolate( out, min, max, Math.random() );\n  },\n\n  /**\n   * [distance description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  distance: function(a, b)\n  {\n    return Math.sqrt( this.distanceSq( a, b ) );\n  },\n\n  /**\n   * [distanceSq description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  distanceSq: function(a, b)\n  {\n    throw 'Calculator.distanceSq not implemented';\n  },\n\n  /**\n   * [length description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  length: function(a)\n  {\n    return this.distance( a, this.ZERO );\n  },\n\n  /**\n   * [lengthSq description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  lengthSq: function(a)\n  {\n    return this.distanceSq( a, this.ZERO );\n  },\n\n  /**\n   * [isValid description]\n   * @param  {[type]}\n   * @return {Boolean}\n   */\n  isValid: function(a)\n  {\n    throw 'Calculator.isValid not implemented';\n  },\n\n  /**\n   * [isNaN description]\n   * @param  {[type]}\n   * @return {Boolean}\n   */\n  isNaN: function(a)\n  {\n    throw 'Calculator.isNaN not implemented';\n  },\n\n  /**\n   * [isZero description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {Boolean}\n   */\n  isZero: function(a, epsilon)\n  {\n    throw 'Calculator.isZero not implemented';\n  },\n\n  /**\n   * [isEqual description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {Boolean}\n   */\n  isEqual: function(a, b, epsilon)\n  {\n    throw 'Calculator.isEqual not implemented';\n  },\n\n  /**\n   * [min description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  min: function(out, a, b)\n  {\n    throw 'Calculator.min not implemented';\n  },\n\n  /**\n   * [max description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  max: function(out, a, b)\n  {\n    throw 'Calculator.max not implemented';\n  },\n\n  /**\n   * [clamp description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  clamp: function(out, min, max)\n  {\n    var distSq = this.distanceSq( out, this.ZERO );\n\n    if ( distSq < min * min )\n    {\n      return this.scale( out, min / Math.sqrt( distSq ) );\n    }\n    else if ( distSq > max * max )\n    {\n      return this.scale( out, max / Math.sqrt( distSq ) );\n    }\n\n    return out;\n  },\n\n  /**\n   * [isRelative description]\n   * @param  {[type]}\n   * @return {Boolean}\n   */\n  isRelative: function(x)\n  {\n    return anim8.isString( x ) && ( x[0] === '-' || x[0] === '+' );\n  },\n\n  /**\n   * [relativeAmount description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  getRelativeAmount: function(x)\n  {\n    var z = parseFloat( x );\n\n    return isNaN(z) ? false : z;\n  }\n\n};\n","\n/**\n * A calculator for number primitives.\n */\nanim8.NumberCalculator = function()\n{\n  this.createConstants();\n};\n\nanim8.override( anim8.NumberCalculator.prototype = new anim8.Calculator(), \n{\n  /**\n   * [parse description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  parse: function(x, defaultValue)\n  {\n    // Values computed live.\n    if ( anim8.isFunction( x ) )\n    {\n      return x;\n    }\n    // Value computed from current value on animator.\n    if ( x === true )\n    {\n      return anim8.computed.current;\n    }\n    // A raw number\n    if ( anim8.isNumber( x ) )\n    {\n      return x;\n    }\n    // A number in a string or a relative number.\n    if ( anim8.isString( x ) )\n    {\n      var amount = this.getRelativeAmount( x );\n      \n      if ( amount !== false )\n      {\n        if ( this.isRelative( x ) )\n        {\n          return anim8.computed.relative( amount );\n        }\n        else\n        {\n          return amount;\n        }\n      }\n    }\n    \n    return defaultValue;\n  },\n  copy: function(out, copy) \n  { \n    return copy;\n  },\n  create: function() \n  {\n    return 0.0;\n  },\n  zero: function(out) \n  {\n    return 0.0;\n  },\n  adds: function(out, amount, amountScale) \n  {\n    return out += amount * amountScale;\n  },\n  mul: function(out, scale) \n  {\n    return out *= scale;\n  },\n  distanceSq: function(a, b) \n  {\n    var ab = a - b;\n    return ab * ab;\n  },\n  distance: function(a, b)\n  {\n    return Math.abs( a - b );\n  },\n  length: function(a)\n  {\n    return Math.abs( a );\n  },\n  lengthSq: function(a)\n  {\n    return a * a;\n  },\n  isValid: function(a) \n  {\n    return typeof a === 'number';\n  },\n  isNaN: function(a) \n  {\n    return isNaN(a);\n  },\n  isZero: function(a, epsilon) \n  {\n    return Math.abs(a) < epsilon;\n  },\n  isEqual: function(a, b, epsilon) \n  {\n    return Math.abs(a - b) < epsilon;\n  },\n  min: function(out, a, b)\n  {\n    return Math.min( a, b );\n  },\n  max: function(out, a, b)\n  {\n    return Math.max( a, b );\n  }\n});\n\n/**\n * Register the calculators.\n */\nanim8.calculator['default'] = anim8.calculator['number'] = new anim8.NumberCalculator();\n","\n/*\n * A calculator for objects with an x and y component (number)\n */\nanim8.Point2dCalculator = function()\n{\n  this.createConstants();\n};\n\nanim8.override( anim8.Point2dCalculator.prototype = new anim8.Calculator(), \n{\n  /**\n   * [parse description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n\tparse: function(x, defaultValue)\n\t{\n    // Values computed live.\n    if ( anim8.isFunction( x ) )\n    {\n      return x;\n    }\n    // Value computed from current value on animator.\n    if ( x === true )\n    {\n      return anim8.computed.current;\n    }\n    // When a number is given a uniform point is returned.\n\t\tif ( anim8.isNumber( x ) )\n\t\t{\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: x\n\t\t\t};\n\t\t}\n    // When an object is given, check for relative values.\n\t\tif ( anim8.isObject( x ) )\n\t\t{\n      var cx = anim8.coalesce( x.x, defaultValue.x );\n      var cy = anim8.coalesce( x.y, defaultValue.y );\n      var rx = this.getRelativeAmount( cx );\n      var ry = this.getRelativeAmount( cy );\n\n      if ( rx !== false && ry !== false )\n      {\n        var parsed = { x: rx, y: ry };\n        var ix = this.isRelative( cx );\n        var iy = this.isRelative( cy );\n\n        if ( ix || iy )\n        {\n          var mask = {\n            x: ix ? 1 : 0,\n            y: iy ? 1 : 0\n          };\n\n          return anim8.computed.relative( parsed, mask );\n        }\n\n        return parsed;\n      }\n\t\t}\n    // Relative values & left/right/middle/center/top/bottom aliases.\n    if ( anim8.isString( x ) )\n    {\n      // If only a relative value is given it will modify the X & Y components evenly.\n      if ( this.isRelative( x ) )\n      {\n        var rx = this.getRelativeAmount( x );\n\n        if ( rx !== false )\n        {\n          return anim8.computed.relative( { x: rx, y: rx } ); \n        }\n      }\n\n      var aliases = {\n        'left':   0,\n        'right':  100,\n        'middle': 50,\n        'center': 50,\n        'top':    0,\n        'bottom': 100\n      };\n      \n      if ( x.indexOf(' ') === -1 )\n      {\n        var _x = parseFloat( x );\n        \n        if ( !isNaN(_x) || x in aliases )\n        {\n          return {\n            x: x in aliases ? aliases[x] : _x,\n            y: x in aliases ? aliases[x] : _x\n          };\n        }\n      }\n      else\n      {\n        var pair = x.split(' ');\n        var _x = parseFloat( pair[0] );\n        var _y = parseFloat( pair[1] );\n        \n        if ((!isNaN(_x) || pair[0] in aliases) && (!isNaN(_y) || pair[1] in aliases))\n        {\n          return {\n            x: pair[0] in aliases ? aliases[pair[0]] : _x,\n            y: pair[1] in aliases ? aliases[pair[1]] : _y\n          };\n        }\n      }\n    }\n    \n    // If no value was given but the default value was given, clone it.\n    if ( anim8.isDefined( defaultValue ) )\n    {\n      return this.clone( defaultValue );      \n    }\n\t\t\n\t\treturn false;\n\t},\n  copy: function(out, copy) \n\t{\n    out.x = copy.x;\n    out.y = copy.y;\n    return out;\n  },\n  create: function() \n\t{\n    return {x: 0.0, y:0.0};\n  },\n  zero: function(out) \n\t{\n    out.x = 0.0;\n    out.y = 0.0;\n    return out;\n  },\n  adds: function(out, amount, amountScale) \n\t{\n    out.x += amount.x * amountScale;\n    out.y += amount.y * amountScale;\n    return out;\n  },\n  mul: function(out, scale) \n\t{\n    out.x *= scale.x;\n    out.y *= scale.y;\n    return out;\n  },\n  distanceSq: function(a, b) \n\t{\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;    \n    return dx * dx + dy * dy;\n  },\n  isValid: function(a) \n\t{\n    return typeof a === 'object' && 'x' in a && 'y' in a;\n  },\n  isNaN: function(a) \n\t{\n    return isNaN(a.x) || isNaN(a.y);\n  },\n  isZero: function(a, epsilon) \n\t{\n    return Math.abs(a.x) < epsilon && \n\t\t\t\t\t Math.abs(a.y) < epsilon;\n  },\n  isEqual: function(a, b, epsilon) \n\t{\n    return Math.abs(a.x - b.x) < epsilon && \n\t\t\t\t\t Math.abs(a.y - b.y) < epsilon;\n  },\n  min: function(out, a, b)\n  {\n    out.x = Math.min(a.x, b.x);\n    out.y = Math.min(a.y, b.y);\n    return out;\n  },\n  max: function(out, a, b)\n  {\n    out.x = Math.max(a.x, b.x);\n    out.y = Math.max(a.y, b.y);\n    return out;\n  },\n  random: function(out, min, max)\n  {\n    out.x = (max.x - min.x) * Math.random() + min.x;\n    out.y = (max.y - min.y) * Math.random() + min.y;\n    return out;\n  }\n});\n\n/**\n * Register all calculators.\n */\nanim8.calculator['2d'] = new anim8.Point2dCalculator();\n","\n/**\n * A calculator for objects with an x, y, and z component (number)\n */\nanim8.Point3dCalculator = function()\n{\n  this.createConstants();\n};\n\nanim8.override( anim8.Point3dCalculator.prototype = new anim8.Calculator(), \n{\n\tparse: function(x, defaultValue)\n\t{\n    // Values computed live.\n    if ( anim8.isFunction( x ) )\n    {\n      return x;\n    }\n    // Value computed from current value on animator.\n    if ( x === true )\n    {\n      return anim8.computed.current;\n    }\n    // When a number is given a uniform point is returned.\n\t\tif ( anim8.isNumber( x ) )\n\t\t{\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: x,\n\t\t\t\tz: x\n\t\t\t};\n\t\t}\n    // When an object is given, check for relative values.\n\t\tif ( anim8.isObject( x ) )\n\t\t{\n      var cx = anim8.coalesce( x.x, defaultValue.x );\n      var cy = anim8.coalesce( x.y, defaultValue.y );\n      var cz = anim8.coalesce( x.z, defaultValue.z );\n      var rx = this.getRelativeAmount( cx );\n      var ry = this.getRelativeAmount( cy );\n      var rz = this.getRelativeAmount( cz );\n\n      if ( rx !== false && ry !== false && rz !== false )\n      {\n        var parsed = { x: rx, y: ry, z: rz };\n        var ix = this.isRelative( cx );\n        var iy = this.isRelative( cy );\n        var iz = this.isRelative( cz );\n\n        if ( ix || iy || iz )\n        { \n          var mask = {\n            x: ix ? 1 : 0,\n            y: iy ? 1 : 0,\n            z: iz ? 1 : 0\n          };\n\n          return anim8.computed.relative( parsed, mask );\n        }\n\n        return parsed;\n      }\n\t\t}\n    // If only a relative value is given it will modify the X, Y, & Z components evenly.\n    if ( this.isRelative( x ) )\n    {\n      var rx = this.getRelativeAmount( x );\n\n      if ( rx !== false )\n      {\n        return anim8.computed.relative( { x: rx, y: rx, z: rx } ); \n      }\n    }\n    \n    // If no value was given but the default value was given, clone it.\n    if ( anim8.isDefined( defaultValue ) )\n    {\n      return this.clone( defaultValue );      \n    }\n\t\t\n\t\treturn false;\n\t},\n  copy: function(out, copy) \n\t{\n    out.x = copy.x;\n    out.y = copy.y;\n\t\tout.z = copy.z;\n    return out;\n  },\n  create: function() \n\t{\n    return {x: 0.0, y:0.0, z:0.0};\n  },\n  zero: function(out) \n\t{ \n    out.x = 0.0;\n    out.y = 0.0;\n\t\tout.z = 0.0;\n    return out;\n  },\n  adds: function(out, amount, amountScale) \n\t{\n    out.x += amount.x * amountScale;\n    out.y += amount.y * amountScale;\n\t\tout.z += amount.z * amountScale;\n    return out;\n  },\n  mul: function(out, scale) \n\t{\n    out.x *= scale.x;\n    out.y *= scale.y;\n\t\tout.z *= scale.z;\n    return out;\n  },\n  distanceSq: function(a, b) \n\t{\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;   \n\t\tvar dz = a.z - b.z; \n    return dx * dx + dy * dy + dz * dz;\n  },\n  isValid: function(a) \n\t{\n    return typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n  },\n  isNaN: function(a) \n\t{\n    return isNaN(a.x) || isNaN(a.y) || isNaN(a.z);\n  },\n  isZero: function(a, epsilon) \n\t{\n    return Math.abs(a.x) < epsilon && \n\t\t\t\t\t Math.abs(a.y) < epsilon && Math.abs(a.z) < epsilon;\n  },\n  isEqual: function(a, b, epsilon) \n\t{\n    return Math.abs(a.x - b.x) < epsilon && \n\t\t  \t\t Math.abs(a.y - b.y) < epsilon && \n\t\t\t\t\t Math.abs(a.z - b.z) < epsilon;\n  },\n  min: function(out, a, b)\n  {\n    out.x = Math.min(a.x, b.x);\n    out.y = Math.min(a.y, b.y);\n    out.z = Math.min(a.z, b.z);\n    return out;\n  },\n  max: function(out, a, b)\n  {\n    out.x = Math.max(a.x, b.x);\n    out.y = Math.max(a.y, b.y);\n    out.z = Math.max(a.z, b.z);\n    return out;\n  },\n  random: function(out, min, max)\n  {\n    out.x = (max.x - min.x) * Math.random() + min.x;\n    out.y = (max.y - min.y) * Math.random() + min.y;\n    out.z = (max.z - min.z) * Math.random() + min.z;\n    return out;\n  }\n});\n\n/**\n * Register the calculator.\n */\nanim8.calculator['3d'] = new anim8.Point3dCalculator();\n","\n/**\n * A calculator for objects with an x, y, z, and angle components.\n */\nanim8.QuaternionCalculator = function()\n{\n  this.createConstants();\n};\n\nanim8.override( anim8.QuaternionCalculator.prototype = new anim8.Calculator(), \n{\n  /**\n   * [parse description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n\tparse: function(x, defaultValue)\n\t{\n    // Values computed live.\n    if ( anim8.isFunction( x ) )\n    {\n      return x;\n    }\n    // Value computed from current value on animator.\n    if ( x === true )\n    {\n      return anim8.computed.current;\n    }\n    // When only a number is given assume it's an angle around the Z-axis.\n\t\tif ( anim8.isNumber( x ) )\n\t\t{\n\t\t\treturn {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\tz: 1,\n\t\t\t\tangle: x\n\t\t\t};\n\t\t}\n    // When an object is given, check for relative values.\n\t\tif ( anim8.isObject( x ) )\n\t\t{\n      var cx = anim8.coalesce( x.x, defaultValue.x );\n      var cy = anim8.coalesce( x.y, defaultValue.y );\n      var cz = anim8.coalesce( x.z, defaultValue.z );\n      var ca = anim8.coalesce( x.angle, defaultValue.angle );\n      var rx = this.getRelativeAmount( cx );\n      var ry = this.getRelativeAmount( cy );\n      var rz = this.getRelativeAmount( cz );\n      var ra = this.getRelativeAmount( ca );\n\n      if ( rx !== false && ry !== false && rz !== false && ra !== false )\n      {\n        var parsed = { x: rx, y: ry, z: rz, angle: ra };\n        var ix = this.isRelative( cx );\n        var iy = this.isRelative( cy );\n        var iz = this.isRelative( cz );\n        var ia = this.isRelative( ca );\n\n        if ( ix || iy || iz || ia )\n        {\n          var mask = {\n            x: ix ? 1 : 0,\n            y: iy ? 1 : 0,\n            z: iz ? 1 : 0,\n            angle: ia ? 1 : 0\n          };\n\n          return anim8.computed.relative( parsed );\n        }\n\n        return parsed;\n      }\n\t\t}\n    // When a relative value is given, assume it's for an angle around the Z-axis.\n    if ( this.isRelative( x ) )\n    {\n      var rx = this.getRelativeAmount( x );\n\n      if ( rx !== false )\n      {\n        return anim8.computed.relative( { x:0, y:0, z:1, angle: rx }, { x:0, y:0, z:0, angle:1 } );\n      }\n    }\n    \n    // If no value was given but the default value was given, clone it.\n    if ( anim8.isDefined( defaultValue ) )\n    {\n      return this.clone( defaultValue );      \n    }\n\t\t\n\t\treturn false;\n\t},\n  copy: function(out, copy) \n\t{\n    out.x = copy.x;\n    out.y = copy.y;\n\t\tout.z = copy.z;\n\t\tout.angle = copy.angle;\n    return out;\n  },\n  create: function() \n\t{\n    return {x: 0.0, y:0.0, z:0.0, angle:0.0};\n  },\n  zero: function(out) \n\t{\n    out.x = 0.0;\n    out.y = 0.0;\n\t\tout.z = 0.0;\n\t\tout.angle = 0.0;\n    return out;\n  },\n  adds: function(out, amount, amountScale) \n\t{\n    out.x += amount.x * amountScale;\n    out.y += amount.y * amountScale;\n\t\tout.z += amount.z * amountScale;\n\t\tout.angle += amount.angle * amountScale;\n    return out;\n  },\n  mul: function(out, scale) \n\t{\n    out.x *= scale.x;\n    out.y *= scale.y;\n\t\tout.z *= scale.z;\n\t\tout.angle *= scale.angle;\n    return out;\n  },\n  distanceSq: function(a, b) \n\t{\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;   \n\t\tvar dz = a.z - b.z; \n\t\tvar da = a.angle - b.angle;\n    return dx * dx + dy * dy + dz * dz + da * da;\n  },\n  isValid: function(a) \n\t{\n    return typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a && 'angle' in a;\n  },\n  isNaN: function(a) \n\t{\n    return isNaN(a.x) || isNaN(a.y) || isNaN(a.z) || isNaN(a.angle);\n  },\n  isZero: function(a, epsilon) \n\t{\n    return Math.abs(a.x) < epsilon && \n\t\t  \t\t Math.abs(a.y) < epsilon && \n\t\t       Math.abs(a.z) < epsilon && \n\t\t       Math.abs(a.angle) < epsilon;\n  },\n  isEqual: function(a, b, epsilon) \n\t{\n    return Math.abs(a.x - b.x) < epsilon && \n\t\t\t\t\t Math.abs(a.y - b.y) < epsilon && \n\t\t\t\t   Math.abs(a.z - b.z) < epsilon && \n\t\t       Math.abs(a.angle - b.angle) < epsilon;\n  },\n  min: function(out, a, b)\n  {\n    out.x = Math.min(a.x, b.x);\n    out.y = Math.min(a.y, b.y);\n    out.z = Math.min(a.z, b.z);\n    out.angle = Math.min(a.angle, b.angle);\n    return out;\n  },\n  max: function(out, a, b)\n  {\n    out.x = Math.max(a.x, b.x);\n    out.y = Math.max(a.y, b.y);\n    out.z = Math.max(a.z, b.z);\n    out.angle = Math.max(a.angle, b.angle);\n    return out;\n  },\n  random: function(out, min, max)\n  {\n    out.x = (max.x - min.x) * Math.random() + min.x;\n    out.y = (max.y - min.y) * Math.random() + min.y;\n    out.z = (max.z - min.z) * Math.random() + min.z;\n    out.angle = (max.angle - min.angle) * Math.random() + min.angle;\n    return out;\n  }\n});\n\n\n/**\n * Register the calculator.\n */\nanim8.calculator['quaternion'] = new anim8.QuaternionCalculator();\n","\n/**\n * A calculator for objects with r, g, & b components (numbers 0 -> 255)\n */\nanim8.RGBCalculator = function()\n{\n  this.createConstants();\n};\n\nanim8.override( anim8.RGBCalculator.prototype = new anim8.Calculator(), \n{\n  /**\n   * [parse description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n\tparse: function(x, defaultValue)\n\t{\n    // Values computed live.\n    if ( anim8.isFunction( x ) )\n    {\n      return x;\n    }\n    // Value computed from current value on animator.\n    if ( x === true )\n    {\n      return anim8.computed.current;\n    }\n    // When a number is given a grayscale color is returned.\n\t\tif ( anim8.isNumber( x ) )\n\t\t{\n\t\t\treturn {\n\t\t\t\tr: x,\n\t\t\t\tg: x,\n\t\t\t\tb: x\n\t\t\t};\n\t\t}\n    // When an object is given, check for relative values.\n    if ( anim8.isObject( x ) )\n    {\n      var cr = anim8.coalesce( x.r, defaultValue.r );\n      var cg = anim8.coalesce( x.g, defaultValue.g );\n      var cb = anim8.coalesce( x.b, defaultValue.b );\n      var rr = this.getRelativeAmount( cr );\n      var rg = this.getRelativeAmount( cg );\n      var rb = this.getRelativeAmount( cb );\n\n      if ( rr !== false && rg !== false && rb !== false )\n      {\n        var parsed = { r: rr, g: rg, b: rb };\n        var ir = this.isRelative( cr );\n        var ig = this.isRelative( cg );\n        var ib = this.isRelative( cb );\n\n        if ( ir || ig || ib )\n        {\n          var mask = {\n            r: ir ? 1 : 0,\n            g: ig ? 1 : 0,\n            b: ib ? 1 : 0\n          };\n\n          return anim8.computed.relative( parsed, mask );\n        }\n\n        return parsed;\n      }\n    }\n    // If only a relative value is given it will modify the R, G, & B components.\n    if ( this.isRelative( x ) )\n    {\n      var rx = this.getRelativeAmount( x );\n\n      if ( rx !== false )\n      {\n        return anim8.computed.relative( { r: rx, g: rx, b: rx } ); \n      }\n    }\n\t\t\n    // Try to parse the color.\n\t\tvar parsed = anim8.color.parse( x );\n\n    if ( parsed !== false )\n    {\n      return parsed;\n    }\n    \n    // If no value was given but the default value was given, clone it.\n    if ( anim8.isDefined( defaultValue ) )\n    {\n      return this.clone( defaultValue );      \n    }\n    \n    return false;    \n\t},\n  copy: function(out, copy) \n\t{\n    out.r = copy.r;\n    out.g = copy.g;\n    out.b = copy.b;\n    return out;\n  },\n  create: function() \n\t{\n    return {r: 0, g:0, b:0};\n  },\n  zero: function(out) \n\t{\n    out.r = 0;\n    out.g = 0;\n    out.b = 0;\n    return out;\n  },\n  adds: function(out, amount, amountScale) \n\t{\n    out.r += amount.r * amountScale;\n    out.g += amount.g * amountScale;\n    out.b += amount.b * amountScale;\n    return out;\n  },\n  mul: function(out, scale) \n\t{\n    out.r *= scale.r;\n    out.g *= scale.g;\n    out.b *= scale.b;\n    return out;\n  },\n  distanceSq: function(a, b) \n\t{\n    var dr = a.r - b.r;\n    var dg = a.g - b.g;    \n    var db = a.b - b.b;    \n    return dr * dr + dg * dg + db * db;\n  },\n  isValid: function(a) \n\t{\n    return anim8.isObject( a ) && 'r' in a && 'g' in a && 'b' in a;\n  },\n  isNaN: function(a) \n\t{\n    return isNaN(a.r) || isNaN(a.g) || isNaN(a.b);\n  },\n  isZero: function(a, epsilon) \n\t{\n    return Math.abs(a.r) < epsilon && \n           Math.abs(a.g) < epsilon && \n           Math.abs(a.b) < epsilon;\n  },\n  isEqual: function(a, b, epsilon) \n\t{\n    return Math.abs(a.r - b.r) < epsilon && \n           Math.abs(a.g - b.g) < epsilon && \n           Math.abs(a.b - b.b) < epsilon;\n  },\n  min: function(out, a, b)\n  {\n    out.r = Math.min(a.r, b.r);\n    out.g = Math.min(a.g, b.g);\n    out.b = Math.min(a.b, b.b);\n    return out;\n  },\n  max: function(out, a, b)\n  {\n    out.r = Math.max(a.r, b.r);\n    out.g = Math.max(a.g, b.g);\n    out.b = Math.max(a.b, b.b);\n    return out;\n  },\n  random: function(out, min, max)\n  {\n    out.r = (max.r - min.r) * Math.random() + min.r;\n    out.g = (max.g - min.g) * Math.random() + min.g;\n    out.b = (max.b - min.b) * Math.random() + min.b;\n    return out;\n  }\n});\n\n/**\n * Register the calculator.\n */\nanim8.calculator['rgb'] = new anim8.RGBCalculator();\n","\n\n/**\n * A calculator for objects with r, g, & b components \n * (numbers 0 -> 255) and an a (alpha) component (0.0 -> 1.0).\n */\nanim8.RGBACalculator = function()\n{\n  this.createConstants();\n};\n\nanim8.override( anim8.RGBACalculator.prototype = new anim8.Calculator(), \n{\n  /**\n   * [parse description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n\tparse: function(x, defaultValue)\n\t{\n    // Values computed live.\n    if ( anim8.isFunction( x ) )\n    {\n      return x;\n    }\n    // Value computed from current value on animator.\n    if ( x === true )\n    {\n      return anim8.computed.current;\n    }\n    // When a number is given an opaque grayscale color is returned.\n\t\tif ( anim8.isNumber( x ) )\n\t\t{\n\t\t\treturn {\n\t\t\t\tr: x,\n\t\t\t\tg: x,\n\t\t\t\tb: x,\n\t\t\t\ta: 1.0\n\t\t\t};\n\t\t}\n    // When an object is given, check for relative values.\n    if ( anim8.isObject( x ) )\n    {\n      var cr = anim8.coalesce( x.r, defaultValue.r );\n      var cg = anim8.coalesce( x.g, defaultValue.g );\n      var cb = anim8.coalesce( x.b, defaultValue.b );\n      var ca = anim8.coalesce( x.a, defaultValue.a );\n      var rr = this.getRelativeAmount( cr );\n      var rg = this.getRelativeAmount( cg );\n      var rb = this.getRelativeAmount( cb );\n      var ra = this.getRelativeAmount( ca );\n\n      if ( rr !== false && rg !== false && rb !== false && ra !== false )\n      {\n        var parsed = { r: rr, g: rg, b: rb, a: ra };\n        var ir = this.isRelative( cr );\n        var ig = this.isRelative( cg );\n        var ib = this.isRelative( cb );\n        var ia = this.isRelative( ca );\n\n        if ( ir || ig || ib || ia )\n        {\n          var mask = {\n            r: ir ? 1 : 0,\n            g: ig ? 1 : 0,\n            b: ib ? 1 : 0,\n            a: ia ? 1 : 0\n          };\n\n          return anim8.computed.relative( parsed, mask );\n        }\n\n        return parsed;\n      }\n    }\n    // If only a relative value is given it will modify the R, G, & B components.\n    if ( this.isRelative( x ) )\n    {\n      var rx = this.getRelativeAmount( x );\n\n      if ( rx !== false )\n      {\n        return anim8.computed.relative( { r: rx, g: rx, b: rx, a: 0 } ); \n      }\n    }\n    \n    // Try to parse the color.\n    var parsed = anim8.color.parse( x );\n\n    if ( parsed !== false )\n    {\n      return parsed;\n    }\n    \n    // If no value was given but the default value was given, clone it.\n    if ( anim8.isDefined( defaultValue ) )\n    {\n      return this.clone( defaultValue );      \n    }\n    \n    return false;  \n\t},\n  copy: function(out, copy) \n\t{\n    out.r = copy.r;\n    out.g = copy.g;\n    out.b = copy.b;\n    out.a = copy.a;\n    return out;\n  },\n  create: function() \n\t{\n    return {r: 0, g:0, b:0, a:0};\n  },\n  zero: function(out) \n\t{\n    out.r = 0;\n    out.g = 0;\n    out.b = 0;\n    out.a = 0;\n    return out;\n  },\n  adds: function(out, amount, amountScale) \n\t{\n    out.r += amount.r * amountScale;\n    out.g += amount.g * amountScale;\n    out.b += amount.b * amountScale;\n    out.a += amount.a * amountScale;\n    return out;\n  },\n  mul: function(out, scale) \n\t{\n    out.r *= scale.r;\n    out.g *= scale.g;\n    out.b *= scale.b;\n    out.a *= scale.a;\n    return out;\n  },\n  distanceSq: function(a, b) \n\t{\n    var dr = a.r - b.r;\n    var dg = a.g - b.g;    \n    var db = a.b - b.b;    \n    var da = a.a - b.a;    \n    return dr * dr + dg * dg + db * db + da * da;\n  },\n  isValid: function(a) \n\t{\n    return anim8.isObject( a ) && 'r' in a && 'g' in a && 'b' in a && 'a' in a;\n  },\n  isNaN: function(a) \n\t{\n    return isNaN(a.r) || isNaN(a.g) || isNaN(a.b) || isNaN(a.a);\n  },\n  isZero: function(a, epsilon) \n\t{\n    return Math.abs(a.r) < epsilon && \n           Math.abs(a.g) < epsilon && \n           Math.abs(a.b) < epsilon && \n           Math.abs(a.a) < epsilon;\n  },\n  isEqual: function(a, b, epsilon) \n\t{\n    return Math.abs(a.r - b.r) < epsilon && \n           Math.abs(a.g - b.g) < epsilon && \n           Math.abs(a.b - b.b) < epsilon && \n           Math.abs(a.a - b.a) < epsilon;\n  },\n  min: function(out, a, b)\n  {\n    out.r = Math.min(a.r, b.r);\n    out.g = Math.min(a.g, b.g);\n    out.b = Math.min(a.b, b.b);\n    out.a = Math.min(a.a, b.a);\n    return out;\n  },\n  max: function(out, a, b)\n  {\n    out.r = Math.max(a.r, b.r);\n    out.g = Math.max(a.g, b.g);\n    out.b = Math.max(a.b, b.b);\n    out.a = Math.max(a.a, b.a);\n    return out;\n  },\n  random: function(out, min, max)\n  {\n    out.r = (max.r - min.r) * Math.random() + min.r;\n    out.g = (max.g - min.g) * Math.random() + min.g;\n    out.b = (max.b - min.b) * Math.random() + min.b;\n    out.a = (max.a - min.a) * Math.random() + min.a;\n    return out;\n  }\n});\n\n/**\n * Register the calculator.\n */\nanim8.calculator['rgba'] = new anim8.RGBACalculator();\n","\n/**\n * [path description]\n * @param  {[type]}\n * @return {[type]}\n */\nanim8.path = function(path)\n{\n  if ( path instanceof anim8.Path )\n  {\n    return path;\n  }\n  if ( anim8.isString( path ) && path in anim8.path )\n  {\n    return anim8.path[ spring ];\n  }\n  if ( anim8.isObject( path ) && path.type in anim8.path )\n  {\n    return anim8.path[ path.type ]( path );\n  }\n  \n  return false;\n};\n\n/**\n * [Path description]\n */\nanim8.Path = function()\n{\n};\n\nanim8.Path.prototype = \n{\n  /**\n   * [reset description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  reset: function(name, calculator, points)\n  {\n    this.name = name;\n    this.calculator = anim8.calculator( calculator );\n    this.points = points;\n    this.computed = this.hasComputed();\n  },\n\n  /**\n   * [compute description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  compute: function(out, delta) \n\t{\n    throw 'Path.compute not implemented';\n  },\n\n  /**\n   * [hasTrue description]\n   * @return {Boolean}\n   */\n  hasComputed: function() \n\t{\n    var ps = this.points;\n    \n    for (var i = 0; i < ps.length; i++) \n    {\n      if ( anim8.isComputed( ps[i] ) )\n      {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * [reference description]\n   * @return {[type]}\n   */\n  reference: function() \n\t{\n    return this.trues ? this.copy() : this;\n  },\n\n  /**\n   * [last description]\n   * @return {[type]}\n   */\n  last: function()\n  {\n    return this.points[ this.points.length - 1 ];\n  },\n\n  /**\n   * [first description]\n   * @return {[type]}\n   */\n  first: function()\n  {\n    return this.points[ 0 ];\n  },\n\n  /**\n   * [point description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  point: function(i)\n  {\n    return this.points[ i ];\n  },\n\n  /**\n   * [replaceComputed description]\n   * @return {[type]}\n   */\n  replaceComputed: function(event, animator)\n  {\n    var clone = this.copy();\n    var ps = clone.points;\n\n    for (var i = 0; i < ps.length; i++)\n    {\n      if ( anim8.isComputed( ps[i] ) )\n      {\n        ps[i] = ps[i]( event, animator );\n      }\n    }\n    \n    return clone;\n  },\n\n  /**\n   * [resolvePoint description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  resolvePoint: function(i)\n  {\n    var p = this.points[ i ];\n    \n    if ( anim8.isFunction( p ) )\n    {\n      p = p();\n    }\n    \n    return p;\n  },\n\n  /**\n   * Returns whether the path is linear. Linear paths go directly from point to\n   * point where curved paths do not. Linear paths can have their length calculated\n   * fairly easily however curves you must compute length with a given granularity.\n   * \n   * @return {Boolean}\n   */\n  isLinear: function()\n  {\n    return true;\n  },\n\n  /**\n   * Computes the length of the Path with a given granularity. Granularity\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  length: function(granularity)\n  {\n    var distance = 0;\n    var calc = this.calculator;\n\n    if ( this.isLinear() )\n    {\n      var prev = this.resolvePoint( 0 );\n\n      for (var i = 1; i < this.points.length; i++)\n      {\n        var next = this.resolvePoint( i );\n\n        distance += calc.distance( prev, next );\n\n        prev = next;\n      }\n    }\n    else\n    {\n      var deltadelta = 1.0 / granularity;\n      var delta = delta;\n      var prev = calc.clone( this.resolvePoint( 0 ) );\n      var temp = calc.create();\n\n      for (var i = 1; i <= granularity; i++)\n      {\n        var next = this.compute( temp, delta );\n\n        distance += calc.distance( prev, next );\n\n        temp = prev;\n        prev = next;\n      }\n    }\n\n    return distance;\n  }\n\n};\n","\n/**\n * [Tween description]\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n */\nanim8.Tween = function(name, calculator, start, end)\n{\n  this.reset( name, calculator, [ start, end ] );\n};\n\nanim8.override( anim8.Tween.prototype = new anim8.Path(),\n{\n  /**\n   * [compute description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  compute: function(out, delta)\n  {\n    return this.calculator.interpolate( out, this.resolvePoint( 0 ), this.resolvePoint( 1 ), delta );\n  },\n\n  /**\n   * [copy description]\n   * @return {[type]}\n   */\n  copy: function() \n  {\n    return new anim8.Tween( this.name, this.calculator, this.points[0], this.points[1] );\n  }\n\n});\n\n/**\n * [tween description]\n * @param  {[type]}\n * @return {[type]}\n */\nanim8.path['tween'] = function(path)\n{\n  var calc = anim8.calculator( path.calculator );\n  \n  return new anim8.Tween(\n    path.name, \n    calc,\n    calc.parse( path.start, calc.ZERO ),\n    calc.parse( path.end, calc.ZERO )\n  );\n};\n","\n/**\n * [CubicPath description]\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n */\nanim8.CubicPath = function(name, calculator, p0, p1, p2, p3)\n{\n  this.reset( name, calculator, [p0, p1, p2, p3] );\n};\n\nanim8.override( anim8.CubicPath.prototype = new anim8.Path(),\n{\n  /**\n   * [compute description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  compute: function(out, d1)\n  {\n    var calc = this.calculator;\n    var d2 = d1 * d1;\n    var d3 = d1 * d2;\n    var i1 = 1 - d1;\n    var i2 = i1 * i1;\n    var i3 = i1 * i2;\n    \n    out = calc.copy( out, this.resolvePoint( 0 ) );\n    out = calc.scale( out, i3 );\n    out = calc.adds( out, this.resolvePoint( 1 ), 3 * i2 * d1 );\n    out = calc.adds( out, this.resolvePoint( 2 ), 3 * i1 * d2 );\n    out = calc.adds( out, this.resolvePoint( 3 ), d3 );\n    \n    return out;\n  },\n  \n  /**\n   * [copy description]\n   * @return {[type]}\n   */\n  copy: function() \n  {\n    return new anim8.CubicPath( this.name, this.calculator, this.points[0], this.points[1], this.points[2], this.points[3] );\n  },\n\n  /**\n   * CubicPath is not a linear Path.\n   * \n   * @return {Boolean}\n   */\n  isLinear: function()\n  {\n    return false;\n  }\n\n});\n\n/**\n * [cubic description]\n * @param  {[type]}\n * @return {[type]}\n */\nanim8.path['cubic'] = function(path)\n{\n  var calc = anim8.calculator( path.calculator );\n  \n  return new anim8.CubicPath(\n    path.name,\n    calc,\n    calc.parse( path.p0 ),\n    calc.parse( path.p1 ),\n    calc.parse( path.p2 ),\n    calc.parse( path.p3 )\n  );\n};\n","\n/**\n * [QuadraticPath description]\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n */\nanim8.QuadraticPath = function(name, calculator, p0, p1, p2)\n{\n  this.reset( name, calculator, [p0, p1, p2] );\n};\n\nanim8.override( anim8.QuadraticPath.prototype = new anim8.Path(),\n{\n  /**\n   * [compute description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  compute: function(out, d1)\n  {\n    var calc = this.calculator;\n    var d2 = d1 * d1;\n    var i1 = 1 - d1;\n    var i2 = i1 * i1;\n    \n    out = calc.copy( out, this.resolvePoint( 0 ) );\n    out = calc.scale( out, i2 );\n    out = calc.adds( out, this.resolvePoint( 1 ), 2 * i1 * d1 );\n    out = calc.adds( out, this.resolvePoint( 2 ), d2 );\n      \n    return out;\n  },\n\n  /**\n   * [copy description]\n   * @return {[type]}\n   */\n  copy: function() \n  {\n    return new anim8.QuadraticPath( this.name, this.calculator, this.points[0], this.points[1], this.points[2] );\n  },\n\n  /**\n   * QuadraticPath is not a linear Path.\n   * \n   * @return {Boolean}\n   */\n  isLinear: function()\n  {\n    return false;\n  }\n\n});\n\n/**\n * [quadratic description]\n * @param  {[type]}\n * @return {[type]}\n */\nanim8.path['quadratic'] = function(path)\n{\n  var calc = anim8.calculator( path.calculator );\n  \n  return new anim8.QuadraticPath(\n    path.name,\n    calc,\n    calc.parse( path.p0 ),\n    calc.parse( path.p1 ),\n    calc.parse( path.p2 )\n  );\n};\n","\n/**\n * [DeltaPath description]\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n */\nanim8.DeltaPath = function(name, calculator, points, deltas) \n{\n  this.reset( name, calculator, points );\n  this.deltas = deltas;\n};\n\nanim8.override( anim8.DeltaPath.prototype = new anim8.Path(),\n{\n  /**\n   * [compute description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  compute: function(out, delta) \n  {\n    var ds = this.deltas;\n    var end = ds.length - 2;\n    var i = 0;\n    while (ds[i + 1] < delta && i < end) i++;\n    var d0 = ds[i];\n    var d1 = ds[i + 1];\n    var pd = (delta - d0) / (d1 - d0);\n    var p0 = this.resolvePoint( i );\n    var p1 = this.resolvePoint( i + 1 );\n    \n    return this.calculator.interpolate( out, p0, p1, pd );\n  },\n  \n  /**\n   * [copy description]\n   * @return {[type]}\n   */\n  copy: function() \n  {\n    return new anim8.DeltaPath( this.name, anim8.copy(this.points), anim8.copy(this.deltas), this.calculator );\n  }\n\n});\n\n/**\n * [delta description]\n * @param  {[type]}\n * @return {[type]}\n */\nanim8.path['delta'] = function(path)\n{\n  var calc = anim8.calculator( path.calculator );\n  \n  if (!path.deltas)\n  {\n    path.deltas = [];\n    \n    for (var i = 0; i < path.points.length; i++)\n    {\n      path.deltas[ i ] = i / ( path.points.length - 1 );\n    }\n  }\n\n  for (var i = 0; i < path.points.length; i++)\n  {\n    path.points[ i ] = calc.parse( path.points[i] );\n  }\n  \n  return new anim8.DeltaPath(\n    path.name,\n    calc,\n    path.points,\n    path.deltas\n  );\n};\n","\n/**\n * [JumpPath description]\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n */\nanim8.JumpPath = function(name, calculator, points)\n{\n  this.reset( name, calculator, points );\n};\n\nanim8.override( anim8.JumpPath.prototype = new anim8.Path(),\n{\n  /**\n   * [compute description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  compute: function(out, delta)\n  {\n    var a = Math.floor( delta * this.points.length );\n    var index = Math.min( a, this.points.length - 1 );\n    \n    return this.calculator.copy( out, this.resolvePoint( index ) );\n  },\n  \n  /**\n   * [copy description]\n   * @return {[type]}\n   */\n  copy: function() \n  {\n    return new anim8.JumpPath( this.name, this.calculator, anim8.copy(this.points) );\n  }\n\n});\n\n/**\n * [jump description]\n * @param  {[type]}\n * @return {[type]}\n */\nanim8.path['jump'] = function(path)\n{\n  var calc = anim8.calculator( path.calculator );\n  \n  for (var i = 0; i < path.points.length; i++)\n  {\n    path.points[ i ] = calc.parse( path.points[i] );\n  }\n  \n  return new anim8.JumpPath(\n    path.name, \n    calc,\n    path.points\n  );\n};\n\n","\n/**\n * [CompiledPath description]\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n */\nanim8.CompiledPath = function(name, path, pointCount)\n{\n  var calc = path.calculator;\n  var points = [];\n  \n  for (var i = 0; i < pointCount; i++)\n  {\n    points.push( path.compute( calc.create(), i / (pointCount - 1) ) );\n  }\n  \n  this.reset( name, calc, points );\n};\n\nanim8.override( anim8.CompiledPath.prototype = new anim8.Path(),\n{\n  /**\n   * [compute description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  compute: function(out, delta)\n  {\n    var a = Math.floor( delta * this.points.length );\n    var index = Math.min( a, this.points.length - 1 );\n    \n    return this.calculator.copy( out, this.resolvePoint( index ) );\n  },\n\n  /**\n   * [copy description]\n   * @return {[type]}\n   */\n  copy: function() \n  {\n    return new anim8.CompiledPath( this.name, this, this.points.length );\n  }\n\n});\n\n/**\n * [compiled description]\n * @param  {[type]}\n * @return {[type]}\n */\nanim8.path['compiled'] = function(path)\n{\n  return new anim8.CompiledPath(\n    path.name,\n    anim8.path( path.path ),\n    path.pointCount\n  );\n};\n","\n/**\n * [KeyframePath description]\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n */\nanim8.KeyframePath = function(name, calculator, points, deltas, easings) \n{\n  this.reset( name, calculator, points );\n  this.deltas = deltas;\n  this.easings = easings;\n};\n\nanim8.override( anim8.KeyframePath.prototype = new anim8.Path(),\n{\n  /**\n   * [compute description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  compute: function(out, delta) \n  {  \n    var ds = this.deltas;\n    var end = ds.length - 2;\n    \n    if ( delta < ds[0] ) {\n      return false;\n    }\n    \n    if ( delta > ds[ds.length - 1] ) {\n      return this.points[ds.length - 1];\n    }\n    \n    var i = 0;\n    while (ds[i + 1] < delta && i < end) i++;\n    var d0 = ds[i];\n    var d1 = ds[i + 1];\n    var pd = (delta - d0) / (d1 - d0);\n    var p0 = this.resolvePoint( i );\n    var p1 = this.resolvePoint( i + 1 );\n    var ea = this.easings[i];\n    \n    return this.calculator.interpolate( out, p0, p1, ea( pd ) );\n  },\n  \n  /**\n   * [copy description]\n   * @return {[type]}\n   */\n  copy: function() \n  {\n    return new anim8.KeyframePath( this.name, this.calculator, anim8.copy(this.points), anim8.copy(this.deltas), anim8.copy(this.easings) );\n  }\n\n});\n\n/**\n * [keyframe description]\n * @param  {[type]}\n * @return {[type]}\n */\nanim8.path['keyframe'] = function(point)\n{\n  var calc = anim8.calculator( path.calculator );\n  \n  if (!path.deltas)\n  {\n    path.deltas = [];\n    \n    for (var i = 0; i < path.points.length; i++)\n    {\n      path.deltas[ i ] = i / ( path.points.length - 1 );\n    }\n  }\n  \n  var defaultEasing = anim8.easing( path.easings, null );\n  \n  if ( !anim8.isDefined( path.easings ) || !anim8.isArray( path.easings ) || defaultEasing !== null )\n  {\n    path.easings = [];\n    \n    for (var i = 0; i < path.points.length; i++)\n    {\n      path.easings[ i ] = defaultEasing;\n    }\n  }\n  \n  for (var i = 0; i < path.easings.length; i++)\n  {\n    path.easings[ i ] = anim8.easing( path.easings[ i ] );\n  }\n  \n  for (var i = 0; i < path.points.length; i++)\n  {\n    path.points[ i ] = calc.parse( path.points[i] );\n  }\n  \n  return new anim8.KeyframePath(\n    path.name,\n    calc,\n    path.points,\n    path.deltas,\n    path.easings\n  );\n};\n","\n/**\n * [PointPath description]\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n */\nanim8.PointPath = function(name, calculator, point)\n{\n  this.reset( name, calculator, [point] );\n};\n\nanim8.override( anim8.PointPath.prototype = new anim8.Path(),\n{\n  /**\n   * [compute description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  compute: function(out, delta)\n  {\n    return this.calculator.copy( out, this.resolvePoint( 0 ) );\n  },\n  \n  /**\n   * [copy description]\n   * @return {[type]}\n   */\n  copy: function() \n  {\n    return new anim8.PointPath( this.name, this.calculator, this.points[0] );\n  }\n\n});\n\n/**\n * [point description]\n * @param  {[type]}\n * @return {[type]}\n */\nanim8.path['point'] = function(path)\n{\n  var calc = anim8.calculator( path.calculator );\n  \n  return new anim8.PointPath(\n    path.name,\n    calc,\n    calc.parse( path.point )\n  );\n};\n","\n/**\n * Animates a single attribute over any period of time.\n */\nanim8.Attrimator = function()\n{\n\n};\n\nanim8.Attrimator.prototype =\n{\n\n  /**\n   * Resets this animator for the given attribute created by the given parser.\n   * \n   * @param  {attribute} string\n   * @param  {anim8.Parser} parser\n   */\n  reset: function(attribute, parser, next)\n  {\n    this.attribute = attribute;\n    this.parser = parser;\n    this.next = next;\n\n    this.startTime = 0;\n    this.pauseTime = 0;\n    this.elapsed = 0;\n    this.stopTime = Number.POSITIVE_INFINITY;\n    this.paused = false;\n    this.cycle = 0;\n    this.delay = 0;\n    this.offset = 0;\n  },\n\n  /**\n   * Prepares this attribute animator for animation on the given subject animator.\n   * This is called once in anim8.Animator.preupdate before the first time this\n   * animator is updated.\n   * \n   * @param  {[type]}\n   * @return {[type]}\n   */\n  start: function(now, animator)\n  {\n    this.startTime = now - this.offset;\n    this.elapsed = this.offset;\n    this.finished = false;\n  },\n\n  /**\n   * [startCycle description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  startCycle: function(frame)\n  {\n    return false;\n  },\n\n  /**\n   * Updates this attribute animator given a time to animate to and the frame to\n   * provide with a new value. This method will return true if the attribute\n   * this is animating has been updated and needs to be applied to the subject.\n   * \n   * @param  {Number} now\n   * @param  {Object} frame\n   * @return {Boolean}\n   */\n  setTime: function(now, frame)\n  {\n    if ( this.paused )\n    {\n      return false;\n    }\n\n    var updated = false;\n    var elapsed = now - this.startTime;\n    var updated = false;\n\n    if ( elapsed > this.stopTime )\n    {\n      updated = this.finish( frame );\n    }\n    else if ( elapsed >= this.delay )\n    {\n      updated = this.update( elapsed, frame );\n    }\n\n    this.elapsed = elapsed;\n\n    return updated;\n  },\n\n  /**\n   * [update description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  update: function(elapsed, frame)\n  {\n    throw 'Attrimator.update not implemented';\n  },\n\n  /**\n   * Returns the amount of time that has elapsed in milliseconds.\n   * \n   * @return {Number}\n   */\n  getElapsed: function()\n  {\n    return this.elapsed;\n  },\n\n  /**\n   * [stopIn description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  stopIn: function(milliseconds)\n  {\n    this.stopTime = this.getElapsed() + milliseconds;\n  },\n\n  /**\n   * Returns the value at the given time.\n   * \n   * @param  {Number} time\n   * @return {any}\n   */\n  valueAt: function(time)\n  {\n    return false;\n  },\n\n  /**\n   * The total amount of time this animator will take. This may be an infinite number.\n   * \n   * @return {Number}\n   */\n  totalTime: function()\n  {\n    return this.stopTime;\n  },\n\n  /**\n   * The time remaining before this animator and any following will be finished.\n   * \n   * @return {Number}\n   */\n  timeRemaining: function() \n  {    \n    return this.totalTime() - this.elapsed + ( this.next ? this.next.timeRemaining() : 0 );\n  },\n\n  /**\n   * Clones this animator.\n   * \n   * @return {anim8.AttributeAnimator}\n   */\n  clone: function()\n  {\n    throw 'AttributeAnimator.clone not implemented';\n  },\n\n  /**\n   * Returns whether this animator has computed values which need to be resolved\n   * by the subject animator calling prepare on this attribute animator.\n   * \n   * @return {Boolean}\n   */\n  hasComputed: function()\n  {\n    return false;\n  },\n\n  /**\n   * Determines whether this animator will run infinitely.\n   * \n   * @return {Boolean}\n   */\n  isInfinite: function()\n  {\n    return (this.stopTime === Number.POSITIVE_INFINITY);\n  },\n\n  /**\n   * [pause description]\n   * @return {[type]}\n   */\n  pause: function()\n  {\n    if ( !this.paused )\n    {\n      this.pauseTime = anim8.now();\n      this.paused = true;\n    }\n  },\n\n  /**\n   * [resume description]\n   * @return {[type]}\n   */\n  resume: function()\n  {\n    if ( this.paused )\n    {\n      this.startTime += anim8.now() - this.pauseTime;\n      this.paused = false;\n    }\n  },\n\n  /**\n   * [isPaused description]\n   * @return {Boolean}\n   */\n  isPaused: function()\n  {\n    return this.paused;\n  },\n\n  /**\n   * Sets the final state of the animator to the frame if one exists.\n   * \n   * @param  {Object}\n   * @return {Boolean}\n   */\n  finish: function(frame)\n  {\n    return false;\n  },\n\n  /**\n   * [isFinished description]\n   * @return {Boolean}\n   */\n  isFinished: function()\n  {\n    return false;\n  },\n\n  /**\n   * Returns the parser that created this animator (if any).\n   * \n   * @return {anim8.Parser}\n   */\n  getParser: function()\n  {\n    return this.parser;\n  },\n\n  /**\n   * \n   * @param  {Function}\n   * @return {[type]}\n   */\n  queue: function(next)\n  {\n    if ( this.next )\n    {\n      this.next.queue( next );\n    }\n    else\n    {\n      this.next = next;\n    }\n  }\n\n};","\n/**\n * [AttributeMap description]\n */\nanim8.AttrimatorMap = function()\n{\n  this.reset();\n};\n\nanim8.override( anim8.AttrimatorMap.prototype = new anim8.FastMap(),\n{\n\n  /**\n   * [queue description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  queue: function(attrimator)\n  {\n    var attr = attrimator.attribute;\n\n    if ( this.has( attr ) )\n    {\n      this.get( attr ).queue( attrimator );\n    }\n    else\n    {\n      this.put( attr, attrimator );\n    }\n  },\n\n  /**\n   * [queueMap description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  queueMap: function(map, onNewAttribute, context)\n  {\n    var maxRemaining = this.timeRemaining();\n    var attrimators = map.values;\n    \n    for (var i = attrimators.length - 1; i >= 0; i--)\n    {\n      var attrimator = attrimators[ i ];\n      var attr = attrimator.attribute;\n      var existing = this.get( attr );\n\n      if ( existing )\n      {\n        if ( existing.isInfinite() )\n        {\n          existing.stopIn( attrimator.delay + maxRemaining );\n        }\n        else\n        {\n          attrimator.delay += (maxRemaining - existing.timeRemaining());\n        }\n\n        existing.queue( attrimator );\n      }\n      else\n      {\n        attrimator.delay += maxRemaining;\n\n        this.put( attr, attrimator );\n\n        if ( anim8.isFunction( onNewAttribute ) )\n        {\n          onNewAttribute.call( context || this, attrimator );\n        }\n      }\n    }\n    \n    return this;\n  },\n\n  /**\n   * [unqueue description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  unqueueAt: function(index)\n  {\n    var current = this.values[ index ];\n\n    if ( current.next )\n    {\n      this.values[ index ] = current.next;\n    }\n    else\n    {\n      this.removeAt( index );\n    }\n  },\n\n  /**\n   * [clone description]\n   * @return {[type]}\n   */\n  clone: function()\n  {\n    var values = this.values;\n    var keys = this.keys;\n    var clone = new anim8.AttrimatorMap();\n\n    for (var i = values.length - 1; i >= 0; i--)\n    {\n      clone.values[i] = values[i].clone();\n      clone.keys[i] = keys[i];\n      clone.indices[ keys[i] ] = i;\n    }\n\n    return clone;\n  },\n\n  /**\n   * [timeRemaining description]\n   * @return {[type]}\n   */\n  timeRemaining: function()\n  {\n    var remaining = 0;\n    var values = this.values;\n\n    for (var i = values.length - 1; i >= 0; i--)\n    {\n      var attrimator = values[i];\n\n      if ( !attrimator.isInfinite() )\n      {\n        remaining = Math.max( remaining, attrimator.timeRemaining() );\n      }\n    }\n\n    return remaining;\n  },\n\n  /**\n   * [applyCycle description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  applyCycle: function(nextCycle)\n  {\n    var currentDepth = this.values;\n    var nextDepth = null;\n\n    while ( currentDepth.length )\n    {\n      nextDepth = [];\n\n      for (var i = currentDepth.length - 1; i >= 0; i--)\n      {\n        var attrimator = currentDepth[ i ];\n\n        attrimator.cycle = nextCycle;\n\n        if ( attrimator.next )\n        {\n          nextDepth.push( attrimator.next );\n        }\n      }\n\n      if ( nextDepth.length )\n      {\n        nextCycle++;\n      }\n\n      currentDepth = nextDepth;\n    }\n\n    return nextCycle;\n  },\n\n});","\n/**\n * [EventState description]\n * @type {[type]}\n */\nanim8.EventState = \n{\n  CREATED: 0,\n  DELAYED: 1,\n  ANIMATING: 2,\n  SLEEPING: 4,\n  PAUSED: 8,\n  FINISHED: 16\n};\n\n/**\n * [Event description]\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {Boolean}\n * @param {[type]}\n * @param {Function}\n */\nanim8.Event = function(attribute, path, duration, easing, delay, sleep, repeat, scale, scaleBase, hasInitialState, parser, next) \n{\n  this.reset( attribute, parser, next )\n\n  this.path             = path;\n  this.easing           = anim8.easing( easing );\n  this.delay            = anim8.delay( delay );\n  this.duration         = anim8.duration( duration );\n  this.sleep            = anim8.sleep( sleep );\n  this.repeat           = anim8.repeat( repeat );\n  this.scale            = anim8.scale( scale );\n  this.scaleBase        = path.calculator.parse( scaleBase, path.calculator.ZERO );\n  this.hasInitialState  = anim8.coalesce( hasInitialState, true );\n};\n\nanim8.override( anim8.Event.prototype = new anim8.Attrimator(),\n{\n\n  /**\n   * Prepares this attribute animator for animation on the given subject animator.\n   * This is called once in anim8.Animator.preupdate before the first time this\n   * animator is updated.\n   * \n   * @param  {[type]}\n   * @return {[type]}\n   */\n  start: function(now, animator)\n  {\n    anim8.Attrimator.prototype.start.apply( this, arguments );\n    \n    this.state = this.delay ? anim8.EventState.DELAYED : anim8.EventState.ANIMATING;\n\n    if ( this.hasComputed() )\n    {\n      this.path = this.path.replaceComputed( this, animator );\n    }\n  },\n\n  /**\n   * [startCycle description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  startCycle: function(frame)\n  {\n    if ( this.hasInitialState )\n    {\n      return this.applyValue( frame, frame[ this.attribute ], 0 );\n    }\n\n    return false;\n  },\n\n  /**\n   * [update description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  update: function(elapsed, frame)\n  {\n    var updated = false;\n    var delay = this.delay;\n    var duration = this.duration;\n    var sleep = this.sleep;\n    var repeat = this.repeat;\n    var oldState = this.state;\n    var newState = this.state;\n    var delta = 0;\n\n    elapsed -= delay;\n\n    var cycle = duration + sleep;\n    var iteration = Math.floor( ( elapsed + sleep ) / cycle );\n\n    if (iteration >= repeat)\n    {\n      newState = anim8.EventState.FINISHED;\n      delta = 1;\n    }\n    else\n    {\n      elapsed -= iteration * cycle;\n\n      if ( elapsed > duration )\n      {\n        newState = anim8.EventState.SLEEPING;\n        delta = 1;\n      }\n      else\n      {\n        newState = anim8.EventState.ANIMATING;\n        delta = elapsed / duration;\n      }\n    }\n    \n    if ( newState === anim8.EventState.ANIMATING || \n       ( newState !== anim8.EventState.ANIMATING && oldState === anim8.EventState.ANIMATING ) )\n    {\n      this.applyValue( frame, frame[ this.attribute ], delta );\n      updated = true;\n    }\n\n    this.state = newState;\n\n    return updated;\n  },\n\n  /**\n   * Computes the value at the given time. The only time when a value won't be\n   * returned is if the time is before the delay and the event doesn't have an\n   * initial state.\n   * \n   * @param  {Number} time\n   * @param  {any} out\n   * @return {any}\n   */\n  valueAt: function(time, out)\n  {\n    if ( time < this.delay && !this.hasInitialState )\n    {\n      return false;\n    }\n\n    var delta = 0;\n\n    if ( time >= this.delay )\n    {\n      var cycle = (this.duration + this.sleep);\n      var elapsed = (time - this.delay);\n      var iteration = Math.floor( ( elapsed + this.sleep ) / cycle );\n\n      if ( iteration >= this.repeat )\n      {\n        delta = 1.0;\n      }\n      else\n      {\n        delta = Math.min( 1.0, (elapsed % cycle) / this.duration );        \n      }\n    }\n\n    return this.computeValue( out, delta );\n  },\n\n  /**\n   * [computeValue description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  computeValue: function(baseValue, delta)\n  {\n    var value = this.path.compute( baseValue, this.easing( delta ) );\n\n    if ( value !== false && this.scale !== 1.0 )\n    {\n      var calc = this.path.calculator;\n      var baseValue = calc.clone( this.scaleBase );\n      var distance = calc.sub( baseValue, value );\n\n      value = calc.adds( value, distance, -this.scale );\n    }\n\n    return value;\n  },\n\n  /**\n   * [finish description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  finish: function(frame) \n  {\n    this.applyValue( frame, this.path.calculator.create(), 1.0 );\n    this.state = anim8.EventState.FINISHED;\n  },\n\n  /**\n   * [applyValue description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  applyValue: function(frame, baseValue, delta)\n  {\n    var value = this.computeValue( baseValue, delta );\n    \n    if ( value !== false )\n    {\n      frame[ this.attribute ] = value;\n    }\n\n    return value;\n  },\n\n  /**\n   * The total amount of time this animator will take. This may be an infinite number.\n   * \n   * @return {Number}\n   */\n\ttotalTime: function()\n\t{\n\t\treturn Math.min( this.stopTime, this.delay + (this.repeat * this.duration) + ((this.repeat - 1) * this.sleep) );\n\t},\n\n  /**\n   * [clone description]\n   * @return {[type]}\n   */\n  clone: function()\n  {\n    return new anim8.Event( this.attribute, this.path, this.duration, this.easing, this.delay, this.sleep, this.repeat, this.scale, this.scaleBase, this.hasInitialState, this.parser, this.next ? this.next.clone() : null );\n  },\n\n  /**\n   * Returns whether this animator has computed values which need to be resolved\n   * by the subject animator calling prepare on this attribute animator.\n   * \n   * @return {Boolean}\n   */\n  hasComputed: function()\n  {\n    return this.path.computed;\n  },\n\n  /**\n   * [isInfinite description]\n   * @return {Boolean}\n   */\n  isInfinite: function()\n  {\n    return (this.repeat === Number.POSITIVE_INFINITY) && (this.stopTime === Number.POSITIVE_INFINITY);\n  },\n\n  /**\n   * [isFinished description]\n   * @return {Boolean}\n   */\n  isFinished: function()\n  {\n    return (this.state === anim8.EventState.FINISHED);\n  }\n\n});\n","/**\n * Returns a spring if the provided argument is a spring, the name of a spring, or\n * an object with a spring type to be created. If none of these conditions are true\n * then false is returned.\n *\n * @param {anim8.Spring|string|object} spring\n */\nanim8.spring = function(spring)\n{\n  if ( spring instanceof anim8.Spring )\n  {\n    return spring;\n  }\n  if ( anim8.isString( spring ) && spring in anim8.spring )\n  {\n    return anim8.spring[ spring ];\n  }\n  if ( anim8.isObject( spring ) && spring.type in anim8.spring )\n  {\n    return anim8.spring[ spring.type ]( spring );\n  }\n  \n  return false;\n};\n\n\n/**\n * A spring has a resting point, a current position, and the velocity currently enacting on the position\n * based on the implementing classes logic.\n */\nanim8.Spring = function()\n{\n};\n\nanim8.override( anim8.Spring.prototype = new anim8.Attrimator(),\n{\n\n  /**\n   * Resets the spring's properties.\n   * \n   * @param {string} attribute\n   * @param {string|object} calculator\n   * @param {any} rest\n   * @param {any} position\n   */\n  set: function(attribute, calculator, rest, position, velocity, gravity, finishOnRest)\n  { \n    this.reset( attribute, null, null );\n\n    this.calculator   = calculator;\n    this.rest         = rest;\n    this.position     = position;\n    this.gravity      = gravity;\n    this.velocity     = velocity;\n    this.finishOnRest = finishOnRest;\n  },\n\n  /**\n   * Called the first time preupdate is called on an Animator to prepare the\n   * spring to be updated.\n   * \n   * @return {[type]}\n   */\n  start: function(now, animator)\n  {\n    anim8.Attrimator.prototype.start.apply( this, arguments );\n\n    var attribute = animator.getAttribute( this.attribute );\n    var calc = anim8.calculator( anim8.coalesce( this.calculator, attribute.calculator ) );\n\n    this.calculator = calc;\n    this.rest       = this.parseValue( animator, this.rest, attribute.defaultValue );\n    this.position   = this.parseValue( animator, this.position, attribute.defaultValue );\n    this.gravity    = this.parseValue( animator, this.gravity, calc.ZERO );\n    this.velocity   = this.parseValue( animator, this.velocity, calc.ZERO );\n  },\n\n  /**\n   * Returns whether this animator has computed values which need to be resolved\n   * by the subject animator calling prepare on this attribute animator.\n   * \n   * @return {Boolean}\n   */\n  hasComputed: function()\n  {\n    return anim8.isComputed( this.rest ) || \n           anim8.isComputed( this.position ) ||\n           anim8.isComputed( this.gravity ) ||\n           anim8.isComputed( this.velocity );\n  },\n\n  /**\n   * [parseValue description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  parseValue: function(animator, value, defaultValue)\n  {\n    var parsed = this.calculator.parse( value, defaultValue );\n\n    if ( anim8.isFunction( parsed ) && parsed.computed )\n    {\n       parsed = parsed( this, animator );\n    }\n\n    return parsed;\n  },\n  \n  /**\n   * Updates the spring given the current time in milliseconds and the frame which\n   * contains (or will contain) the attribute to which this spring is animating.\n   *\n   * @param {number} elapsed\n   * @param {object} frame\n   */\n  update: function(elapsed, frame)\n  {\n    var calc = this.calculator;\n    \n    // the number of elapsed seconds (maxed to avoid crazy behavior with low FPS)\n    var dt = Math.min( (elapsed - this.elapsed) * 0.001, anim8.Spring.MAX_DT );\n    \n    // keep track of the starting position to determine whether the position has updated.\n    var starting = calc.clone( this.position );\n    \n    // call the update method which should update the position\n    this.updateVelocity( dt );\n    this.velocity = calc.adds( this.velocity, this.gravity, dt );\n    this.position = calc.adds( this.position, this.velocity, dt );\n    \n    // track whether the attribute has updated so the animator knows if it needs to apply the attribute to the subject.\n    var updated = !calc.isEqual( starting, this.position, anim8.Spring.EPSILON );\n    \n    if ( updated )\n    {\n      frame[ this.attribute ] = this.position;\n    }\n    else if ( this.finishOnRest && calc.isZero( this.velocity ) )\n    {\n      this.finished = true;\n    }\n    \n    return updated;\n  },\n  \n  /**\n   * Resolves the position to the expected format.\n   */\n  resolveRest: function()\n  {\n    return anim8.resolve( this.rest );\n  },\n  \n  /**\n   * Method that's invoked on each update.\n   *\n   * @param {number} dt\n   */\n  updateVelocity: function(dt)\n  {\n    throw 'Spring.updateVelocity not implemented';\n  },\n\n  /**\n   * Sets the final state of the animator to the frame if one exists.\n   * \n   * @param  {Object}\n   * @return {Boolean}\n   */\n  finish: function(frame)\n  {\n    this.finished = true;\n\n    return true;\n  },\n\n  /**\n   * [isFinished description]\n   * @return {Boolean}\n   */\n  isFinished: function()\n  {\n    return this.finished;\n  }\n\n});\n\n/**\n * The maximum elapsed time that should be used for the spring simulation. If you allow the elapsed time\n * to get to high the spring will overreact and produce undesirable results.\n */\nanim8.Spring.MAX_DT = 0.1;\n\n/**\n * The value used to determine whether two positions in a spring are different.\n */\nanim8.Spring.EPSILON = 0.0001;\n\n","\n/**\n * [LinearSpring description]\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n */\nanim8.LinearSpring = function(attribute, calculator, position, rest, damping, stiffness, velocity, gravity, finishOnRest)\n{\n  this.set( attribute, calculator, rest, position, velocity, gravity, finishOnRest );\n  \n  this.damping      = damping;\n  this.stiffness    = stiffness;\n  this.temp0        = null;\n  this.temp1        = null;\n};\n\nanim8.override( anim8.LinearSpring.prototype = new anim8.Spring(), \n{\n\n  /**\n   * Called the first time preupdate is called on an Animator to prepare the\n   * spring to be updated.\n   * \n   * @return {[type]}\n   */\n  start: function(now, animator)\n  {\n    anim8.Spring.prototype.start.apply( this, arguments );\n\n    var attribute = animator.getAttribute( this.attribute );\n    var calc = this.calculator;\n\n    this.damping      = this.parseValue( animator, this.damping, attribute.defaultValue );\n    this.stiffness    = this.parseValue( animator, this.stiffness, attribute.defaultValue );\n    this.temp0        = calc.create();\n    this.temp1        = calc.create();\n  },\n\n  /**\n   * [clone description]\n   * @return {[type]}\n   */\n  clone: function()\n  {\n    return new anim8.LinearSpring( this.attribute, this.calculator, this.position, this.rest, this.damping, this.stiffness, this.velocity, this.gravity, this.finishOnRest );\n  },\n\n  /**\n   * Returns whether this animator has computed values which need to be resolved\n   * by the subject animator calling prepare on this attribute animator.\n   * \n   * @return {Boolean}\n   */\n  hasComputed: function()\n  {\n    return anim8.isComputed( this.rest ) || \n           anim8.isComputed( this.position ) ||\n           anim8.isComputed( this.gravity ) ||\n           anim8.isComputed( this.velocity ) ||\n           anim8.isComputed( this.damping ) || \n           anim8.isComputed( this.stiffness );\n  },\n\n  updateVelocity: function(dt)\n  {\n    // velocity += ((stiffness * (position - rest)) - (damping * velocity)) * elapsed.seconds;\n    // position += velocity * elapsed.seconds;\n      \n    var calc = this.calculator;\n\n    this.temp1 = calc.copy( this.temp1, this.damping );\n    this.temp1 = calc.mul( this.temp1, this.velocity );\n    \n    this.temp0 = calc.copy( this.temp0, this.position );\n    this.temp0 = calc.sub( this.temp0, this.resolveRest() );\n    this.temp0 = calc.mul( this.temp0, this.stiffness );\n    this.temp0 = calc.sub( this.temp0, this.temp1 );\n    \n    this.velocity = calc.adds( this.velocity, this.temp0, dt );\n  }\n\n});\n\n/**\n * Register the spring parser.\n * \n * @param  {object}\n * @return {anim8.LinearSpring}\n */\nanim8.spring['linear'] = function(spring)\n{ \n  return new anim8.LinearSpring(\n    spring.attribute,\n    spring.calculator,\n    anim8.coalesce( spring.position, true ),\n    anim8.coalesce( spring.rest, true ),\n    spring.damping,\n    spring.stiffness,\n    spring.velocity,\n    spring.gravity,\n    spring.finishOnRest\n  );\n};","\n/**\n * [DistanceSpring description]\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n */\nanim8.DistanceSpring = function(attribute, calculator, position, rest, distance, damping, stiffness, velocity, gravity, finishOnRest)\n{\n  this.set( attribute, calculator, rest, position, velocity, gravity, finishOnRest );\n  \n  this.distance   = distance;\n  this.damping    = damping;\n  this.stiffness  = stiffness;\n  this.temp       = null;\n};\n\nanim8.override( anim8.DistanceSpring.prototype = new anim8.Spring(), \n{\n\n  /**\n   * [start description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  start: function(now, animator)\n  {\n    anim8.Spring.prototype.start.apply( this, arguments );\n    \n    this.temp = this.calculator.create();\n  },\n\n  /**\n   * [clone description]\n   * @return {[type]}\n   */\n  clone: function()\n  {\n    return new anim8.DistanceSpring( this.attribute, this.calculator, this.position, this.rest, this.distance, this.damping, this.stiffness, this.velocity, this.gravity, this.finishOnRest );\n  },\n\n  updateVelocity: function(dt)\n  {\n    // d = DISTANCE( position, rest )\n    // velocity += ((position - rest) / d * stiffness * |distance - d| - (damping * velocity)) * elapsed.seconds;\n    // position += velocity * elapsed.seconds;\n\n    var calc = this.calculator;\n    var rest = this.resolveRest();\n    \n    var d = calc.distance( this.position, rest );\n    \n    this.temp = calc.copy( this.temp, this.position )\n    this.temp = calc.sub( this.temp, rest );\n    \n    if ( d !== 0 )\n    {\n      this.temp = calc.scale( this.temp, 1.0 / d );\n      this.temp = calc.scale( this.temp, (d - this.distance) * this.stiffness );\n    }\n\n    this.temp = calc.adds( this.temp, this.velocity, -this.damping );\n\n    this.velocity = calc.adds( this.velocity, this.temp, dt );\n  }\n});\n\n/**\n * Register the spring parser.\n * \n * @param  {object}\n * @return {anim8.LinearSpring}\n */\nanim8.spring['distance'] = function(spring)\n{ \n  return new anim8.DistanceSpring(\n    spring.attribute,\n    spring.calculator,\n    anim8.coalesce( spring.position, true ),\n    anim8.coalesce( spring.rest, true ),\n    spring.distance,\n    spring.damping,\n    spring.stiffness,\n    spring.velocity,\n    spring.gravity,\n    spring.finishOnRest\n  );\n};","\n/**\n * Animates a single attribute over any period of time.\n */\nanim8.Physics = function( attribute, parser, calculator, position, velocity, acceleration, terminal, stopTime )\n{\n  this.reset( attribute, parser, null );\n\n  this.calculator   = calculator;\n  this.position     = position;\n  this.velocity     = velocity;\n  this.acceleration = acceleration;\n  this.terminal     = anim8.number( terminal, Number.POSITIVE_INFINITY );\n  this.stopTime     = anim8.time( stopTime, Number.POSITIVE_INFINITY );\n  this.finished     = false;\n};\n\nanim8.override( anim8.Physics.prototype = new anim8.Attrimator(),\n{\n\n  /**\n   * Prepares this attribute animator for animation on the given subject animator.\n   * This is called once in anim8.Animator.preupdate before the first time this\n   * animator is updated.\n   * \n   * @param  {[type]}\n   * @return {[type]}\n   */\n  start: function(now, animator)\n  {\n    anim8.Attrimator.prototype.start.apply( this, arguments );\n\n    var attribute = animator.getAttribute( this.attribute );\n    var calc = anim8.calculator( anim8.coalesce( this.calculator, attribute.calculator ) );\n\n    this.calculator     = calc;\n    this.position       = this.parseValue( animator, this.position, attribute.defaultValue );\n    this.initalPosition = calc.clone( this.position );\n    this.velocity       = this.parseValue( animator, this.velocity, calc.ZERO );\n    this.acceleration   = this.parseValue( animator, this.acceleration, calc.ZERO );\n    this.temp           = calc.create();\n  },\n\n  /**\n   * Returns whether this animator has computed values which need to be resolved\n   * by the subject animator calling prepare on this attribute animator.\n   * \n   * @return {Boolean}\n   */\n  hasComputed: function()\n  {\n    return anim8.isComputed( this.position ) || \n           anim8.isComputed( this.velocity ) ||\n           anim8.isComputed( this.acceleration );\n  },\n\n  /**\n   * [parseValue description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  parseValue: function(animator, value, defaultValue)\n  {\n    var parsed = this.calculator.parse( value, defaultValue );\n\n    if ( anim8.isFunction( parsed ) && parsed.computed )\n    {\n       parsed = parsed( this, animator );\n    }\n\n    return parsed;\n  },\n\n  /**\n   * \n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  update: function(elapsed, frame)\n  {\n    var value = this.valueAt( elapsed, this.temp, true );\n\n    if ( value !== false )\n    {\n      frame[ this.attribute ] = this.position = value;\n\n      return true;\n    }\n\n    var calc = this.calculator;\n    var dt = Math.min( (elapsed - this.elapsed) * 0.001, anim8.Physics.MAX_DT );\n    var vel = calc.copy( this.temp, this.resolveVelocity() );\n    var acc = this.resolveAcceleration();\n    var pos = this.position;\n\n    vel = calc.adds( vel, acc, dt );\n\n    if ( this.terminal !== Number.POSITIVE_INFINITY )\n    {\n      vel = calc.clamp( vel, 0, this.terminal );\n    }\n\n    pos = calc.adds( pos, vel, dt );\n    \n    this.position = pos;\n\n    if ( !anim8.isFunction( this.velocity ) )\n    {\n      this.velocity = calc.copy( this.velocity, vel );\n    }\n\n    frame[ this.attribute ] = pos;\n\n    return true;\n  },\n\n  /**\n   * [resolveVelocity description]\n   * @return {[type]}\n   */\n  resolveVelocity: function()\n  {\n    return anim8.resolve( this.velocity );\n  },\n\n  /**\n   * [resolveAcceleration description]\n   * @return {[type]}\n   */\n  resolveAcceleration: function()\n  {\n    return anim8.resolve( this.acceleration );\n  },\n\n  /**\n   * Returns the value at the given time.\n   * \n   * @param  {Number} time\n   * @return {any}\n   */\n  valueAt: function(time, out, usePosition)\n  {\n    if ( anim8.isFunction( this.velocity ) || anim8.isFunction( this.acceleration ) || this.terminal !== Number.POSITIVE_INFINITY )\n    {\n      return false;\n    }\n\n    time -= this.delay;\n    time *= 0.001;\n\n    var calc = this.calculator;\n    var value = usePosition ? calc.copy( this.position, this.initalPosition ) : calc.copy( out, this.initalPosition );\n    value = calc.adds( value, this.velocity, time );\n    value = calc.adds( value, this.acceleration, time * time );\n\n    return value;\n  },\n\n  /**\n   * Clones this animator.\n   * \n   * @return {anim8.AttributeAnimator}\n   */\n  clone: function()\n  {\n    return new anim8.Physics( this.attribute, this.parser, this.calculator, this.position, this.velocity, this.acceleration, this.terminal, this.stopTime );\n  },\n\n  /**\n   * Sets the final state of the animator to the frame if one exists.\n   * \n   * @param  {Object}\n   * @return {Boolean}\n   */\n  finish: function(frame)\n  {\n    this.finished = true;\n\n    return true;\n  },\n\n  /**\n   * [isFinished description]\n   * @return {Boolean}\n   */\n  isFinished: function()\n  {\n    return this.finished;\n  }\n\n});\n\n/**\n * The maximum elapsed time that should be used for the spring simulation. If you allow the elapsed time\n * to get to high the spring will overreact and produce undesirable results.\n */\nanim8.Physics.MAX_DT = 0.1;","\n/**\n * Returns an animation based on the input. If the input is an instance of anim8.Animation that instance\n * is immediately returned. If the input is a string the animation with that name is returned. If the\n * input is an object an anonymous animation is created using the second options argument. If no animation\n * could be determined then false is returned.\n * \n * @param {anim8.Animation|string|object} animation\n * @param [object] options\n * @param [boolean] cache\n */\nanim8.animation = function(animation, options, cache)\n{\n  if ( animation instanceof anim8.Animation )\n  {\n    return animation;\n  }\n\tif ( anim8.isString( animation ) )\n\t{\n    var key = animation.toLowerCase();\n\n    if ( key in anim8.animation )\n    {\n      return anim8.animation[ key ];\n    }\n\n    var animationStrings = animation.split(',');\n    var anim = false;\n    var last = false;\n\n    for (var k = 0; k < animationStrings.length; k++)\n    {\n      var split = anim8.trim( animationStrings[ k ].toLowerCase() ).split(' ');\n      var parsedAnimation = anim8.animation[ split[ 0 ] ];\n      var parsedOptions = anim8.options( split.slice( 1 ) );\n\n      if ( parsedAnimation )\n      {\n        if ( anim === false )\n        {\n          last = anim = parsedAnimation.extend( parsedOptions, true );\n        }\n        else\n        {\n          last = last.next = parsedAnimation.extend( parsedOptions, true );\n        }\n      }\n      else\n      {\n        throw parsedAnimation + ' is not a valid animation in \"' + animationStrings[ k ] + '\"';\n      }\n    }\n\n    if ( anim8.coalesce( cache, anim8.defaults.cache ) && anim8.isEmpty( options ) )\n    {\n      anim.name = animation;\n\n      anim8.animation[ key ] = anim;\n    }\n\n    return anim;\n\t}\n\tif ( anim8.isObject( animation ) )\n\t{\n    var attrimatorMap = new anim8.AttrimatorMap();\n\t\tvar options = anim8.options( options );\n    var helper = new anim8.ParserHelper( animation, options );\n\t\t\n\t\tfor (var parserName in animation)\n\t\t{\n\t\t\tvar parser = anim8.parser( parserName );\n\t\t\t\n\t\t\tif ( parser !== false )\n\t\t\t{\n\t\t\t\tparser.parse( animation, options, attrimatorMap, helper );\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (attrimatorMap.size())\n\t\t{\n\t\t\treturn new anim8.Animation( false, animation, options, attrimatorMap );\n\t\t}\n    else\n    {\n      throw 'Failed to create any attrimators in anim8.animation';\n    }\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Saves an animation under the given name. It can be played, queued, and transitioned into\n * at a later time providing the name and optionally options to override with.\n *\n * @param {string} name\n * @param {object} animation\n * @param [object] options\n */\nanim8.save = function(name, animation, options)\n{\n  var animation = anim8.animation( animation, options );\n  var key = name.toLowerCase();\n\n  animation.name = name;\n  \n  anim8.animation[ key ] = animation;\n};\n\n/**\n * Instantiates a new Animation given it's name, the input & options passed, and the attrimators that\n * were generated from the input & options. If the name is false this is an anonymous animation.\n * Input & Options are used by parsers to generate attrimators, options allow for an animations\n * default event properties to be overriden.\n *\n * @param {string} name\n * @param {object} input\n * @param [object] options\n * @param {array:anim8.Event} attrimators\n */\nanim8.Animation = function(name, input, options, attrimators)\n{\n\tthis.name = name;\n\tthis.input = input;\n\tthis.options = options;\n\tthis.attrimators = attrimators;\n  this.next = null;\n};\n\nanim8.Animation.prototype = \n{\n  \n  /**\n   * Returns true if this animation was a saved animation, otherwise it's an anonymous one\n   * and false is returned.\n   */\n  isSaved: function()\n  {\n    return (this.name !== false);\n  },\n  \n  /**\n   * Generates an map of event instances from the attrimators in this animation.\n   *\n   * @return {anim8.AttrimatorMap}\n   */\n  newAttrimators: function()\n  {\n    return this.attrimators.clone();\n  },\n\n  /**\n   * Merges options with the options in this animation and places them in the\n   * events.\n   * \n   * @param  {object} options\n   * @param  {anim8.AttrimatorMap} attrimatorMap\n   * @return {[type]}\n   */\n  merge: function(options, attrimatorMap)\n  {\n    var helper = new anim8.ParserHelper( this.input, this.options, options );\n\n    for (var parserName in this.input)\n    {\n      var parser = anim8.parser( parserName );\n      \n      if ( parser !== false )\n      {\n        parser.merge( this.input, options, this.options, attrimatorMap, helper );\n      }\n    }\n\n    return attrimatorMap;\n  },\n\n  /**\n   * Extends this animation and returns an animation modified with the given options. \n   *\n   * @param {object} options\n   */\n  extend: function(options, force)\n  {\n    if ( anim8.isEmpty( options ) && !force )\n    {\n      return this;\n    }\n\n    var attrimatorMap = this.newAttrimators();\n\n    this.merge( options, attrimatorMap );\n\n    anim8.extend( options, this.options );\n\n    return new anim8.Animation( false, this.input, options, attrimatorMap );\n  }\n\n};","\n/**\n * Parses a value into a transition object. If the given input is a string it's\n * expected to be in a similar format to:\n *\n * [time] [easing[-easingType]] >[outro] <[intro] /[granularity] ^[lookup]\n * \n * This is also a registry of transitions, you can add your own transitions that\n * can be used later with syntax like:\n *\n * anim8.transition['myTransition'] = anim8.transition('50ms 0.05 linear');\n *\n * So you can use 'myTransition' as the transition input.\n * \n * @param {object|string|array} options\n * @param {boolean} cache\n * @return {object}\n */\nanim8.transition = function(transition, cache) \n{\n  // 1. If it's a string, convert it into an array.\n  // 2. If it's an array, parse it and convert it into an object.\n  // 3. If it's an object, fill in any missing values with the defaults.\n\n  var originalInput = transition;\n\n  if ( anim8.isString( transition ) )\n  {\n    if ( transition in anim8.transition )\n    {\n      return anim8.transition[ transition ];\n    }\n\n    transition = transition.toLowerCase().split(' ');\n  }\n\n  if ( anim8.isArray( transition ) )\n  {\n    var transitionArray = transition;\n\n    transition = {};\n\n    for (var i = 0; i < transitionArray.length; i++)\n    {\n      var part = transitionArray[i];\n      var first = part.charAt( 0 );\n\n      // Introduction Time (into next event)\n      if ( first === '<' )\n      {\n        var intro = anim8.time( part.substring(1), false );\n\n        if ( !isNaN( intro ) )\n        {\n          transition.intro = intro;\n        }\n      }\n      // Outroduction Time (out of current event)\n      else if ( first === '>' )\n      {\n        var outro = anim8.time( part.substring(1), false );\n\n        if ( !isNaN( outro ) )\n        {\n          transition.outro = outro;\n        }\n      }\n      // Granularity (for velocity conscious transitions)\n      else if ( first === '/' )\n      {\n        var granularity = anim8.number( part.substring(1), false );\n\n        if ( granularity !== false )\n        {\n          transition.granularity = granularity;\n        }\n      }\n      // Lookup (for velocity conscious transitions)\n      else if ( first === '^' )\n      {\n        var lookup = anim8.time( part.substring(1), false );\n\n        if ( lookup !== false )\n        {\n          transition.lookup = lookup;\n        }\n      }\n      else\n      {\n        // Easing\n        var easing = anim8.easing( part, false );\n\n        if ( easing !== false )\n        {\n          transition.easing = easing;\n        }\n\n        // Time\n        var time = anim8.time( part, false );\n\n        if ( time !== false )\n        {\n          transition.time = time;\n        }\n      }\n    }\n  }\n\n  if ( anim8.isObject( transition ) )\n  {\n    transition.time        = anim8.time( transition.time, anim8.defaults.transitionTime );\n    transition.outro       = anim8.time( transition.outro, anim8.defaults.transitionOutro );\n    transition.intro       = anim8.time( transition.intro, anim8.defaults.transitionIntro );\n    transition.easing      = anim8.easing( anim8.coalesce( transition.easing, anim8.defaults.transitionEasing ) );\n    transition.granularity = anim8.number( transition.granularity, anim8.defaults.transitionGranularity );\n    transition.lookup      = anim8.time( transition.lookup, anim8.defaults.transitionLookup );\n    \n    if ( anim8.isString( originalInput ) && anim8.coalesce( cache, anim8.defaults.cacheTransitions ) )\n    {\n      anim8.transition[ originalInput ] = transition;\n    }\n\n    return transition;\n  }\n\n  return anim8.defaults.noTransition;\n};\n","\n/**\n * Parses a value into an options object. If the given input is a string it's \n * expected to be in a similar format to:\n *\n * [duration] x[repeat] z[sleep] ~[delay] ![scale] [easing[-easingType]]\n *\n * This is also a registry of options, you can add your own options that\n * can be used later with syntax like:\n *\n * anim8.option['myOptions'] = anim8.option('1.5s x2 !2');\n *\n * So you can use 'myOptions' as the options input.\n * \n * @param {object|string|array} options\n * @param {boolean} cache\n * @return {object}\n */\nanim8.options = (function()\n{\n  function parseProperty(input, out, parseFunction, property, propertyAdd, propertyScale)\n  {\n    var first = input.charAt( 0 );\n\n    if ( first === '*' )\n    {\n      parsed = anim8.number( input.substring( 1 ), false );\n\n      if ( parsed !== false )\n      {\n        out[ propertyScale ] = parsed;\n      }\n    }\n    else\n    {\n      if ( first === '+' || first === '-' )\n      {\n        property = propertyAdd;\n        input = input.substring( 1 );\n      }\n\n      var parsed = parseFunction( input, false )\n\n      if ( parsed !== false )\n      {\n        out[ property ] = parsed;\n      }  \n    }\n\n    return parsed;\n  }\n\n  return function(options, cache)\n  {\n    var originalInput = options;\n\n    if ( anim8.isString( options ) )\n    {\n      if ( options in anim8.options )\n      {\n        return anim8.options[ options ];\n      }\n\n      options = options.toLowerCase().split(' ');\n    }\n\n    if ( anim8.isArray( options ) )\n    {\n      var parsed = {};\n\n      for (var i = 0; i < options.length; i++)\n      {\n        var part = options[i];\n        var first = part.charAt( 0 );\n\n        // Repeats\n        if ( first === 'x' )\n        {\n          parseProperty( part.substring(1), parsed, anim8.repeat, 'repeat', 'repeatAdd', 'repeatScale' );\n        }\n        // Sleeping\n        else if ( first === 'z' )\n        {\n          parseProperty( part.substring(1), parsed, anim8.time, 'sleep', 'sleepAdd', 'sleepScale' );\n        }\n        // Delay\n        else if ( first === '~' )\n        {\n          parseProperty( part.substring(1), parsed, anim8.time, 'delay', 'delayAdd', 'delayScale' );\n        }\n        // Scaling\n        else if ( first === '!' )\n        {\n          parseProperty( part.substring(1), parsed, anim8.number, 'scale', 'scaleAdd', 'scaleScale' );\n        }\n        else\n        {\n          // Easing?\n          var easing = anim8.easing( part, false );\n\n          if ( easing !== false )\n          {\n            parsed.easing = easing;\n          }\n\n          // Duration?\n          var duration = parseProperty( part, parsed, anim8.time, 'duration', 'durationAdd', 'durationScale' );\n\n          if ( duration === false )\n          {\n            // If not a duration, might be an alternative repeat? (doesn't start with x)\n            parseProperty( part, parsed, anim8.repeat, 'repeat', 'repeatAdd', 'repeatScale' );\n          }\n        }\n      }\n\n      if ( anim8.isString( originalInput ) && anim8.coalesce( cache, anim8.defaults.cacheOptions ) )\n      {\n        anim8.options[ originalInput ] = parsed;\n      }\n\n      return parsed; \n    }\n\n    if ( anim8.isObject( options ) )\n    {\n      return options;\n    }\n\n    return anim8.defaults.noOptions;\n  };\n\n})();","\n/**\n * Instantiates a new Animator given a subject to animate.\n *\n * @param {any} e\n */\nanim8.Animator = function(e) \n{\n\tthis.reset( e );\n};\n\nanim8.fn = anim8.Animator.prototype = \n{\n  /**\n   * Resets the animator given a subject to animate.\n   *\n   * @param {any} e\n   */\n\treset: function(subject)\n\t{\n\t  this.subject = subject;\n    this.attrimators = new anim8.AttrimatorMap();\n    this.attrimatorsAdded = [];\n\t  this.frame = {};\n    this.updated = {};\n\t  this.finished = false;\n\t\tthis.factory = null;\n    this.active = false;\n    this.cycleCurrent = 0;\n    this.cycleNext = 0;\n    this.cycleEnded = 0;\n    \n    return this;\n\t},\n\n  /**\n   * Starts a new animation cycle. This is done before events & springs are placed\n   * to group them together so we know when to apply their initial value.\n   * \n   * @return {this}\n   */\n  newCycle: function(attrimators)\n  {\n    this.cycleNext++;\n\n    if ( attrimators instanceof anim8.AttrimatorMap )\n    {\n      this.cycleNext = attrimators.applyCycle( this.cycleNext );\n    }\n    else if ( attrimators instanceof anim8.Attrimator )\n    {\n      attrimators.cycle = this.cycleNext;\n    }\n\n    return this;\n  },\n\n  /**\n   * Applies the current cycle. This involves finding all events & springs with the same cycle\n   * identifier and applying their initial state.\n   * \n   * @return {this}\n   */\n  applyCurrentCycle: function()\n  {\n    var cycle = this.cycleCurrent;\n    var attrimators = this.attrimators.values;\n\n    for (var i = attrimators.length - 1; i >= 0; i--)\n    {\n      var attrimator = attrimators[ i ];\n      var attr = attrimator.attribute;\n\n      if ( attrimator.cycle === cycle )\n      {\n        this.updated[ attr ] = (attrimator.startCycle( this.frame ) !== false) || this.updated[ attr ];\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * [endCurrentCycle description]\n   * @return {[type]}\n   */\n  endCurrentCycle: function()\n  {\n    if ( this.cycleCurrent > this.cycleEnded )\n    {\n      this.cycleEnded = this.cycleCurrent;\n      this.trigger( 'cycleEnd:' + this.cycleCurrent, this.cycleCurrent ); \n    }\n  },\n\n  /**\n   * Returns the attribute descriptor\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  getAttribute: function(attr)\n  {\n    return this.factory.attribute( attr );\n  },\n  \n  /**\n   * Restores any temporary state that may exist on this Animator that\n   * is a result from animations.\n   */\n  restore: function()\n  { \n    return this;\n  },\n  \n  /**\n   * A method thats invoked along with all other animators before updates are called.\n   * This is used to make any necessary preparations before the animator is updated.\n   */\n  preupdate: function(now)\n  {\n    // If there are attribute placed on the animator since the last preupdate\n    // that has computed values we need to replace the path on the event with\n    // a copy containing the computed values. This is where current value & \n    // relative values are injected from the animator into the attribute.\n    var aa = this.attrimatorsAdded;\n    if ( aa.length )\n    {\n      for (var i = 0; i < aa.length; i++)\n      {\n        var attrimator = aa[ i ];\n\n        this.setDefault( attrimator.attribute );\n\n        attrimator.start( now, this );     \n      }\n\n      aa.length = 0;\n    }\n\n    this.trigger('preupdate');\n    \n    return this;\n  },\n\n  /**\n   * Sets the default value for the given attribute in the frame of this Animator if there's no value there.\n   * \n   * @param {[type]}\n   */\n  setDefault: function(attr)\n  {\n    if ( !(attr in this.frame) )\n    {\n      this.frame[ attr ] = this.getAttribute( attr ).cloneDefault();\n    }\n  },\n  \n  /**\n   * Updates the animator with the current time. All events and springs in this\n   * animator are updated.\n   *\n   * @param {number} now\n   */\n  update: function(now) \n\t{  \n    this.wasFinished = this.finished;\n    this.finished = true;\n\n    var attrimators = this.attrimators.values;\n    var minCycle = this.cycleNext;\n\n    for (var i = attrimators.length - 1; i >= 0; i--)\n    {\n      var attrimator = attrimators[ i ];\n      var attr = attrimator.attribute;\n\n      this.updated[ attr ] = attrimator.setTime( now, this.frame );\n\n      this.finished = this.finished && attrimator.isFinished();\n\n      minCycle = Math.min( minCycle, attrimator.cycle );\n    }\n\n    if ( this.cycleCurrent < minCycle )\n    {\n      while ( this.cycleCurrent < minCycle )\n      {\n        this.endCurrentCycle();\n        this.cycleCurrent++;\n      }\n\n      this.cycleCurrent = minCycle;\n      this.applyCurrentCycle();\n      this.trigger( 'cycleStart:' + this.cycleCurrent, this.cycleCurrent );\n    }\n\n    if ( !this.wasFinished && this.finished )\n    {\n      this.endCurrentCycle();\n    }\n\n    this.trigger('update');\n    \n    return this;\n  },\n\n  /**\n   * Places the attribute animator in this animator replacing any existing animator\n   * for the same attribute. The next time the animator is updated the attribute\n   * animator will be started.\n   * \n   * @param  {anim8.Attrimator}\n   */\n  placeAttrimator: function(attrimator)\n  {\n    var attr = attrimator.attribute;\n\n    this.attrimators.put( attr, attrimator );\n    this.attrimatorsAdded.push( attrimator );\n\n    this.finished = false;\n  },\n  \n  /**\n   * Applies all updated attributes to the subject. This method is invoked with all of the other\n   * animators at the end of the animation cycle.\n   */\n  apply: function()\n\t{\n    for (var attr in this.frame)\n    {\n      if ( this.updated[ attr ] )\n      {\n        this.subject[ attr ] = this.frame[ attr ]; \n\t\t\t\tthis.updated[ attr ] = false;\n      }\n    }\n\t\n\t\tthis.trigger('apply');\n\t\n    this.trimAttrimators();\n    \n    return this;\n  },\n  \n  /**\n   * Removes any finished events and places queued events. If the animator previously wasn't finished\n   * but now it is the 'finished' event will be triggered.\n   */\n  trimAttrimators: function()\n  {\n    var attrimators = this.attrimators.values;\n\n    for (var i = attrimators.length - 1; i >= 0; i--)\n    {\n      var attrimator = attrimators[ i ];\n\n      if ( attrimator.isFinished() )\n      {\n        if ( attrimator.next )\n        {\n          this.placeAttrimator( attrimator.next );\n        }\n        else\n        {\n          this.attrimators.removeAt( i );\n        }\n      }\n    }\n    \n    if ( !this.wasFinished && this.finished )\n    {\n      this.trigger( 'finished', this );\n    }\n  },\n  \n  /**\n   * Returns the current value for the given attribute (or undefined if the attribute is not or \n   * has not animated).\n   *\n   * @param {string} attr\n   */\n  value: function(attr)\n  {\n    return this.frame[ attr ];\n  },\n\n  /**\n   * Activates this Animator by adding it to the main loop if it isn't there already.\n   * \n   * @return {[type]}\n   */\n  activate: function()\n  {\n    anim8.add( this );\n\n    return this;\n  },\n  \n  /**\n   * A method that is invoked when an animator is finished and is being removed from the list\n   * of currently animating Animators.\n   */\n\tdeactivate: function()\n\t{ \n    this.trigger('deactivate', this);\n\t},\n  \n  /**\n   * A method that can be invoked to destroy an animator - removing any relationship between\n   * the subject and animator. The next time an animator is generated for the subject a new\n   * one will be created.\n   */\n  destroy: function()\n  {\n    this.finished = true;\n\n    this.factory.destroy( this );\n    \n    this.trigger('destroyed');\n  },\n  \n  /**\n   * Creates event instances for the given animation and options. The animation can be an animation\n   * object or an animation name. If a name is provided the options are merged in.\n   *\n   * @param {anim8.Animation|string|object} animation\n   * @param [object] options\n   */\n  createAttrimators: function(animation, options, cache)\n  {\n    var options = anim8.options( options );    \n    var animation = anim8.animation( animation, options, cache );\n  \n    if (animation === false)\n    {\n      return false;\n    }\n    \n    var attrimators = animation.newAttrimators();\n    \n    if ( animation.isSaved() && !anim8.isEmpty( options ) )\n    { \n      animation.merge( options, attrimators );\n    }\n    \n    this.onAnimation( animation, options, attrimators );\n\n    while ( animation.next !== null )\n    {\n      animation = animation.next;\n\n      var queueAttrimators = animation.newAttrimators();\n\n      this.onAnimation( animation, options, queueAttrimators );\n\n      attrimators.queueMap( queueAttrimators );\n    }\n\n    return attrimators;\n  },\n  \n  /**\n   * A method invoked when an animation is about to be played in the Animator.\n   * \n   * @param {anim8.Animation} animation\n   * @param {object} options\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   */\n  onAnimation: function(animation, options, attrimatorMap)\n  {\n    \n  },\n  \n  /**\n   * Adds a spring to this animator replacing any existing spring for the same attribute.\n   * A spring object can be given, an instance of anim8.Spring, or a name of a saved Spring.\n   * \n   * @param {anim8.Spring|string|object} spring\n   */\n  spring: function(spring)\n  {\n    var spring = anim8.spring( spring );\n    \n    if ( spring === false )\n    {\n      return false;\n    }\n\n    this.newCycle( spring );\n    this.placeAttrimator( spring );\n    \n    this.activate();\n    \n    return spring;\n  },\n  \n  /**\n   * Adds an animation to this Animator optionally finishing events for attributes not specified in the\n   * given attribute. Existing events will be replaced immediately.\n   *\n   * @param {string|object|anim8.Animation} animation\n   * @param [object] options\n   * @param [boolean] all \n   * @param [boolean] cache\n   */\n\tplay: function(animation, options, all, cache)\n\t{\n    var attrimatorMap = this.createAttrimators( animation, options, cache );\n    \n    if ( attrimatorMap === false )\n    {\n      return false;\n    }\n    \n    this.newCycle( attrimatorMap );\n    this.playAttrimators( attrimatorMap, all );\n\n    return this.activate();\n\t},\n\n  /**\n   * Adds events to this Animator to be played (optionally finishing events for attributes not specified in the given \n   * attribute). Existing events will be replaced immediately. This method will not activate the Animator, that has\n   * to be done manually.\n   * \n   * @param  {anim8.AttributeMap} animatorMap\n   * @param  [boolean] all\n   * @return {this}\n   */\n  playAttrimators: function(attrimatorMap, all)\n  {\n    if ( all )\n    {\n      this.finishNotPresent( attrimatorMap, 0 );\n    }\n\n    var attrimators = attrimatorMap.values;\n\n    for (var i = attrimators.length - 1; i >= 0; i--)\n    {\n      this.placeAttrimator( attrimators[i] );\n    }\n    \n    return this;\n  },\n\n  /**\n   * [finishNotPresent description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  finishNotPresent: function(attrimatorMap, delay)\n  {\n    var attrimators = this.attrimators.values;\n\n    for (var i = attrimators.length - 1; i >= 0; i--)\n    {\n      var attrimator = attrimators[ i ];\n\n      if ( !attrimatorMap.has( attrimator.attribute ) )\n      {\n        attrimator.stopIn( delay );\n      }\n    }\n  },\n  \n  /**\n   * Queues an animation on this Animator. The events generated for the given animation\n   * will all start at the same time - at the end of the events currently on the Animator.\n   *\n   * @param {string|object|anim8.Animation} animation\n   * @param [object] options\n   */\n\tqueue: function(animation, options, cache)\n\t{\n    var attrimatorMap = this.createAttrimators( animation, options, cache );\n    \n    if ( attrimatorMap === false )\n    {\n      return false;\n    }\n        \n    this.newCycle( attrimatorMap );\n    this.queueAttrimators( attrimatorMap );\n\n    return this.activate();\n\t},\n\n  /**\n   * Queues an array of events on this Animator. The given events will be delayed to start at the same time - at the\n   * end of the events currently on the Animator. This method will not activate the Animator, that has to be done \n   * manually.\n   * \n   * @param  {array} events\n   * @return {this}\n   */\n  queueAttrimators: function(attrimatorMap)\n  {\n    this.attrimators.queueMap( attrimatorMap, this.placeAttrimator, this );\n    \n    return this;\n  },\n  \n  /**\n   * Transitions from the currently playing events into the beginning of a new animation. \n   * The transition is made by constructing a quadratic curve from the current value to a \n   * point further on the current path to the starting point of the new animation.\n   *\n   * @param {string|array|object} transition\n   * @param {string|object|anim8.Animation} animation\n   * @param [object] options\n   * @param [boolean] all\n   * @param [Boolean] cache\n   */\n  transition: function(transition, animation, options, all, cache)\n  {\n    var transition = anim8.transition( transition );\n    var attrimatorMap = this.createAttrimators( animation, options, cache );\n    \n    if ( attrimatorMap === false )\n    {\n      return false;\n    }\n\n    this.newCycle( attrimatorMap );\n    this.transitionAttrimators( transition, attrimatorMap, all );\n\n    return this.activate();\n  },\n\n  /**\n   * Transitions from the currently playing events into the beginning of a new animation. \n   * The transition is made by constructing a quadratic curve from the current value to a \n   * point further on the current path to the starting point of the new animation. This method will not activate the \n   * Animator, that has to be done manually.\n   *\n   * @param {object} transition\n   * @param {anim8.AttrimatorMap} events\n   * @param [boolean] all\n   */\n  transitionAttrimators: function(transition, attrimatorMap, all)\n  {\n    // CREATING A TRANSITION PATH:\n    // If intro & outro are 0, use Tween\n    // If intro is 0, use Quadratic Path between current value, outro point, and first point on new path.\n    // If outro is 0, use Quadratic Path between current value, first point on new path, and intro point.\n    // If intro & outro are not 0, use Cubic Path between current value, outro point, first point on new path, and intro point.\n    // If granularity is given > 1 then compile the path, compute intro & outro velocities, and compute deltas for new \n    //    compiled path based on interpolated velocity over the path (knowing it's length and transition time)\n    \n    // TRANSITIONING:\n    // If the animator doesn't have an attrimator for the given attribute just add the attrimator adding the total delay\n    // If the animator has an attrimator currently...\n    //   If the current attrimator or new attrimator don't have values at the desired times...\n    //      Stop the current attrimator after the total delay (adding the delay of the new attrimator as well)\n    //      Queue the new attrimator\n    //   Else\n    //      Create a path using the methods detailed above\n    // If all is true and there's an attrimator left on the animator that isn't being transitioned, stop it after the total delay.\n\n    var current = this.attrimators;\n    var attrimators = attrimatorMap.values;\n    var totalDelay = transition.outro + transition.time + transition.intro;\n\n    // If transition all attributes, \n    if ( all )\n    {\n      this.finishNotPresent( attrimatorMap, totalDelay );\n    }\n\n    // Only transition if we need to\n    if ( current.hasOverlap( attrimatorMap ) )\n    {\n      for (var i = attrimators.length - 1; i >= 0; i--)\n      {\n        var next = attrimators[ i ];\n        var attr = next.attribute;\n        var curr = current.get( attr );\n\n        if ( curr && anim8.isDefined( this.frame[ attr ] ) )\n        {\n          var attribute = this.getAttribute( attr );\n          var calc = attribute.calculator;\n\n          var p2 = next.valueAt( 0, calc.create() );\n          \n          if ( p2 !== false )\n          {\n            var transitionTime = totalDelay;\n            var p0 = calc.clone( this.frame[ attr ] );            \n            var p1 = transition.outro ? curr.valueAt( curr.getElapsed() + transition.outro, calc.create() ) : false;\n            var p3 = transition.intro ? next.valueAt( transition.intro, calc.create() ) : false;\n            var path = null;\n\n            // If the intro is negative we can look into the past by looking a little bit into\n            // the future and assume the past is going in the same direction (only the opposite). \n            if ( p3 !== false && transition.intro < 0 && transition.lookup > 0 )\n            {\n              var pastLookahead = next.valueAt( transition.lookup, calc.create() );\n              var pastVelocity = calc.sub( pastLookahead, p2 );\n\n              if ( pastVelocity !== false )\n              {\n                var pastNegativeVelocity = calc.scale( pastVelocity, transition.intro / transition.lookup );\n                var past = calc.add( pastNegativeVelocity, p2 );\n                \n                p3 = p2;\n                p2 = past;\n              }\n            }\n\n            // Build a path with as many as the points as possible.\n            if ( p1 === false && p3 === false )\n            {\n              path = new anim8.Tween( attr, calc, p0, p2 );\n            }\n            else if ( p1 === false )\n            {\n              path = new anim8.QuadraticPath( attr, calc, p0, p2, p3 );\n            }\n            else if ( p3 === false )\n            {\n              path = new anim8.QuadraticPath( attr, calc, p0, p1, p2 );\n            }\n            else\n            {\n              path = new anim8.CubicPath( attr, calc, p0, p1, p2, p3 );\n            }\n            \n            // If granularity is specified we will try to make the transition \n            // smooth by maintaining exit (outro) velocity from the current attrimator\n            // and interpolating it to the entrance (intro) velocity for the \n            // attrimator we're transitioning into.\n            if ( transition.granularity > 2 && transition.lookup > 0 )\n            { \n              var outTime  = p1 === false ? curr.getElapsed() : curr.getElapsed() + transition.outro;\n              var outPoint = p1 === false ? p0 : p1;\n              var outNext  = curr.valueAt( outTime + transition.lookup, calc.create() );\n\n              var inTime   = p3 === false ? 0 : transition.intro;\n              var inPoint  = p3 === false ? p2 : p3;\n              var inNext   = next.valueAt( inTime + transition.lookup, calc.create() );\n\n              // We can only proceed if we have reference points to calculate\n              // exit & entrance velocity.\n              if ( outNext !== false && inNext !== false )\n              {\n                var outVelocity  = calc.sub( calc.clone( outNext ), outPoint );\n                var outPerMillis = calc.length( outVelocity ) / transition.lookup;\n\n                var inVelocity   = calc.sub( calc.clone( inNext ), inPoint );\n                var inPerMillis  = calc.length( inVelocity ) / transition.lookup;\n\n                var compiled = new anim8.CompiledPath( attr, path, transition.granularity );\n                var points = compiled.points;\n                var lastPoint = points.length - 1;\n                var totalDistance = 0;\n                var distances = [];\n\n                for (var k = 0; k < lastPoint; k++)\n                {\n                  distances[ k ] = totalDistance;\n                  totalDistance += calc.distance( points[ k ], points[ k + 1 ] );\n                }\n                distances[ lastPoint ] = totalDistance;\n\n                if ( !isNaN( totalDistance ) )\n                {\n                  var requiredTime = 2.0 * totalDistance / (outPerMillis + inPerMillis);\n                  var acceleration = 0.5 * (inPerMillis - outPerMillis) / requiredTime;\n                  var timeDelta = requiredTime / lastPoint;\n                  var deltas = [];\n\n                  for (var k = 0; k < lastPoint; k++)\n                  { \n                    var time = k * timeDelta;\n                    var position = outPerMillis * time + acceleration * time * time;\n\n                    deltas[ k ] = position / totalDistance;\n                  }\n                  deltas[ lastPoint ] = 1.0;\n\n                  path = new anim8.DeltaPath( attr, calc, points, deltas );\n                  transitionTime = requiredTime;\n                }\n              }\n            }\n\n            var transitionEvent = new anim8.Event( attr, path, transitionTime, transition.easing, 0, 0, 1 );\n          \n            transitionEvent.next = next;\n            transitionEvent.cycle = next.cycle;\n\n            next.offset = transition.intro;\n\n            this.placeAttrimator( transitionEvent );\n          }\n          else\n          {\n            curr.stopIn( totalDelay + next.delay );\n            curr.queue( next );\n            next.delay = 0;\n          }\n        }\n        else\n        {\n          next.delay += totalDelay;\n          \n          this.placeAttrimator( next );\n        }\n      }\n    }\n    // We don't need to transition, just play the events\n    else\n    {\n      for (var i = attrimators.length - 1; i >= 0; i--)\n      {\n        this.placeAttrimator( attrimators[ i ] );\n      }\n    }\n    \n    return this;\n  },\n\n  /**\n   * Tweens a single attribute to a target value.\n   *\n   * @param {string} attr\n   * @param {any} target\n   * @param [string|number] duration\n   * @param [string|number] delay\n   * @param [string|function] easing\n   * @param [string|number] repeat\n   * @param [string|number] sleep\n   * @param [number] scale\n   * @param [any] scaleBase\n   */\n  tweenTo: function(attr, target, options)\n  {\n    var options   = anim8.options( options );\n    var attribute = this.getAttribute( attr );\n    var end       = attribute.parse( target );\n    var path      = new anim8.Tween( attr, attribute.calculator, anim8.computed.current, end );\n    var event     = new anim8.Event( attr, path, options.duration, options.easing, options.delay, options.sleep, options.repeat, options.scale, options.scaleBase );\n    \n    this.newCycle( event );\n    this.placeAttrimator( event );\n    \n    return this.activate();\n  },\n\n  /**\n   * Tweens a multiple attribute to target values.\n   *\n   * @param {object} targets\n   * @param [string|number] duration\n   * @param [string|number] delay\n   * @param [string|function] easing\n   * @param [string|number] repeat\n   * @param [string|number] sleep\n   * @param [number] scale\n   * @param [any] scaleBase\n   */\n  tweenManyTo: function(targets, options)\n  {\n    var options = anim8.options( options );\n\n    this.newCycle();\n\n    for ( var attr in targets )\n    {\n      var attribute = this.getAttribute( attr );\n      var end       = attribute.parse( targets[ attr ] );\n      var path      = new anim8.Tween( attr, attribute.calculator, anim8.computed.current, end );\n      var event     = new anim8.Event( attr, path, options.duration, options.easing, options.delay, options.sleep, options.repeat, options.scale, options.scaleBase );\n      \n      event.cycle = this.cycleNext;\n      this.placeAttrimator( event );\n    }\n\n    return this.activate();\n  },\n  \n  /**\n   * Tweens an attribute from a starting value to an ending value.\n   *\n   * @param {string} attr\n   * @param {any} starts\n   * @param {any} ends\n   * @param [string|number] duration\n   * @param [string|number] delay\n   * @param [string|function] easing\n   * @param [string|number] repeat\n   * @param [string|number] sleep\n   * @param [number] scale\n   * @param [any] scaleBase\n   */\n  tween: function(attr, starts, ends, options)\n  {\n    var options   = anim8.options( options );\n    var attribute = this.getAttribute( attr );\n    var start     = attribute.parse( starts );\n    var end       = attribute.parse( ends );\n    var path      = new anim8.Tween( attr, attribute.calculator, start, end );\n    var event     = new anim8.Event( attr, path, options.duration, options.easing, options.delay, options.sleep, options.repeat, options.scale, options.scaleBase );\n    \n    this.newCycle( event );\n    this.placeAttrimator( event );\n\n    return this.activate();\n  },\n  \n  /**\n   * Tweens multiple attributes from starting values to ending values.\n   *\n   * @param {object} starts\n   * @param {object} ends\n   * @param [string|number] duration\n   * @param [string|number] delay\n   * @param [string|function] easing\n   * @param [string|number] repeat\n   * @param [string|number] sleep\n   * @param [number] scale\n   * @param [any] scaleBase\n   */\n  tweenMany: function(starts, ends, options)\n  {\n    var options = anim8.options( options );\n\n    this.newCycle();\n\n    for ( var attr in starts )\n    {\n      var attribute = this.getAttribute( attr );\n      var start     = attribute.parse( starts[ attr ] );\n      var end       = attribute.parse( ends[ attr ] );\n      var path      = new anim8.Tween( attr, attribute.calculator, start, end );\n      var event     = new anim8.Event( attr, path, options.duration, options.easing, options.delay, options.sleep, options.repeat, options.scale, options.scaleBase );\n      \n      event.cycle = this.cycleNext;\n      this.placeAttrimator( event );\n    }\n\n    return this.activate();\n  },\n  \n  /**\n   * Returns a function that returns the current value for the given attribute when invoked.\n   * \n   * @param {string} attribute\n   */\n  ref: function(attr)\n  {\n    var animator = this;\n    var attribute = this.getAttribute( attr );\n    var request = {};\n    \n    return function()\n    {\n      if ( attr in animator.frame )\n      {\n        return animator.frame[ attr ];\n      }\n      \n      request[ attr ] = true;\n      \n      var current = animator.get( request );\n      \n      if ( anim8.isDefined( current[ attr ] ) )\n      {\n        return current[ attr ];\n      }\n      \n      return attribute.defaultValue;\n    };\n  },\n  \n  /**\n   * Follows the attribute along the given path definition.\n   * \n   * @param {string} attribute\n   * @param {anim8.Path|object|string} path\n   * @param [number|string] duration\n   * @param [number|string] delay\n   * @param [function|string] easing\n   * @param [number|string] repeat\n   * @param [number|string] sleep  \n   * @param [number] scale\n   */\n  follow: function(attribute, path, options)\n  {\n    var options = anim8.options( options );\n    var path = anim8.path( path );\n    \n    var event = new anim8.Event( \n      attribute, \n      path, \n      options.duration,\n      options.easing,\n      options.delay, \n      options.sleep,\n      options.repeat,\n      options.scale,\n      options.scaleBase\n    );\n    \n    this.newCycle( event );\n    this.placeAttrimator( event );\n    \n    return this.activate();\n  },\n  \n  /**\n   * Helper method that calls a callback for each object in the given map that exists\n   * in the attribute string/array.\n   *\n   * @param {string|array} attributes\n   * @param {function} callback\n   * @param {object} objects\n   */\n  attrimatorsFor: function(attributes, callback, objects)\n  {\n\t\tif ( anim8.isString( attributes ) )\n\t\t{\n\t\t\tattributes = attributes.split( ' ' );\n\t\t}\n   \n    var attrimatorMap = this.attrimators; \n    var resulting = !anim8.isFunction( callback );\n    var results = [];\n    \n\t\tif ( anim8.isArray( attributes ) )\n\t\t{\n      for (var i = 0; i < attributes.length; i++)\n      {\n        var attr = attributes[i];\n        var attrimator = attrimatorMap.get( attr );\n        \n        if ( attrimator )\n        {\n          if ( resulting )\n          {\n            results.push( attrimator );\n          }\n          else\n          {\n            callback.call( this, attrimator, attr );\n          }\n        }\n      }\n\t\t}\n    else\n    {\n      var attrimators = attrimatorMap.values;\n\n      for (var i = attrimators.length - 1; i >= 0; i--)\n      {\n        var attrimator = attrimators[ i ];\n\n        if ( resulting )\n        {\n          results.push( attrimator );\n        }\n        else\n        {\n          callback.call( this, attrimator, attrimator.attribute );\n        }\n      }\n    }\n    \n\t\treturn resulting ? results : this;\n  },\n\t\n  /**\n   * Stops all events for the specified attributes. Attribute names can be given as an array\n   * or a space separated string. If no attributes are given all attributes are assumed.\n   *\n   * @param {string|array} attributes\n   */\n\tstop: function(attributes)\n\t{\n\t\treturn this.attrimatorsFor( attributes, function(attrimator, attr) \n\t\t{\n      this.attrimators.remove( attr );\n\t\t});\n\t},\n  \n  /**\n   * Ends all events for the specified attributes. If events are queued the last value of the last event\n   * is applied to this Animator before being completely removed. Attribute names can be given as an array\n   * or a space separated string. If no attributes are given all attributes are assumed.\n   *\n   * @param {string|array} attributes\n   */\n\tend: function(attributes)\n\t{\n\t\treturn this.attrimatorsFor( attributes, function(attrimator) \n\t\t{\n\t\t\twhile (attrimator.next)\n\t\t\t{\n\t\t\t\tattrimator = attrimator.next;\n\t\t\t}\n\t\t\t\n\t\t\tattrimator.finish( this.frame );\n\t\t});\n\t},\n  \n  /**\n   * Finishes all current events for the specified attributes. Attribute names can be given as an array\n   * or a space separated string. If no attributes are given all attributes are assumed.\n   *\n   * @param {string|array} attributes\n   */\n\tfinish: function(attributes)\n\t{\n\t\treturn this.attrimatorsFor( attributes, function(attrimator)\n\t\t{\n\t\t\tattrimator.finish( this.frame );\n\t\t});\n\t},\n  \n  /**\n   * Pauses all current events for the specified attributes. Attribute names can be given as an array\n   * or a space separated string. If no attributes are given all attributes are assumed.\n   *\n   * @param {string|array} attributes\n   */\n\tpause: function(attributes)\n\t{\n\t\treturn this.attrimatorsFor( attributes, function(attrimator)\n\t\t{\n\t\t\tattrimator.pause();\n\t\t});\n\t},\n  \n  /**\n   * Resumes all current events for the specified attributes. Attribute names can be given as an array\n   * or a space separated string. If no attributes are given all attributes are assumed.\n   *\n   * @param {string|array} attributes\n   */\n\tresume: function(attributes)\n\t{\n\t\treturn this.attrimatorsFor( attributes, function(attrimator)\n\t\t{\n\t\t\tattrimator.resume();\n\t\t});\n\t},\n  \n  /**\n   * Sets the given attributes to this Animator immediately.\n   *\n   * @param {object} attributes\n   */\n  set: function(attributes)\n  {\n    for (var attr in attributes)\n    {\n      this.frame[ attr ] = attributes[ attr ];\n\t\t\tthis.updated[ attr ] = true;\n    }\n    \n    this.apply();\n    \n    return this;\n  },\n\n  /**\n   * Unsets the attribute, array of attributes, or object of attribtues. Unsetting involves removing all events,\n   * springs, and the current value in the frame.\n   * \n   * @param  {string|array|object}\n   * @return {this}\n   */\n  unset: function(attributes)\n  {\n    if ( anim8.isString( attributes ) )\n    {\n      this.attrimators.remove( attributes );\n      delete this.frame[ attributes ];\n    }\n    else if ( anim8.isArray( attributes ) )\n    {\n      for (var i = 0; i < attributes.length; i++)\n      {\n        this.unset( attributes[ i ] );\n      }\n    }\n    else if ( anim8.isObject( attributes ) )\n    {\n      for (var attr in attributes)\n      {\n        this.unset( attr );\n      }\n    }\n\n    return this;\n  },\n  \n  /**\n   * Gets the current attribute values for all attributes specified. The argument must be an object\n   * where the key is the name of an attribute.\n   *\n   * @param {object} attributes\n   */\n  get: function(attributes)\n  {\n    var out = {};\n    \n    for (var attr in attributes)\n    {\n      out[ attr ] = this.frame[ attr ];\n    }\n    \n    return out;\n  },\n\n  /**\n   * Returns the amount of finite time remaining before the animator is done\n   * animating. Attrimators that don't have a known end time aren't included.\n   */\n  timeRemaining: function()\n  {\n    return this.attrimators.timeRemaining();\n  },\n  \n  /**\n   * Returns true if there are any events on this Animator.\n   */\n  hasAttrimators: function()\n  {\n    return this.attrimators.size() > 0;\n  },\n  \n  /**\n   * Returns the subject of the Animator optionally passing it through a wrapper\n   * function before it's returned.\n   *\n   * @param [function] wrapper\n   */\n  getSubject: function(wrapper)\n  {\n    var subject = this.subject;\n\n    if ( anim8.isFunction( wrapper ) )\n    {\n      subject = wrapper( subject );\n    }\n\n    return subject;\n  },\n\n  /**\n   * Invokes a function with the given context or the context of this Animator if none is given. This is particularly\n   * useful for having a function be called on deferred statements.\n   * \n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  invoke: function(func, context, args)\n  {\n    if ( anim8.isFunction( func ) )\n    {\n      func.apply( context || this, args || [] );\n    }\n  },\n\t\n\t/**\n\t * Defers the method calls following this one to when the given event type (on or once) and event.\n\t * To return this animator you need to call undefer() as many times as you called defer().\n\t *\n\t * @param {string} eventType\n\t * @param {string} event\n   * @param [function] callback\n\t */\n\tdefer: function(eventType, event, callback)\n\t{\n\t\treturn new anim8.DeferAnimator( this, this, eventType, event, callback );\n\t},\n\n  /**\n   * [onStart description]\n   * @param  {Function}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  onCycleStart: function(callback, context)\n  {\n    this.once( 'cycleStart:' + this.cycleNext, callback, context );\n  },\n\n  /**\n   * [onEnd description]\n   * @param  {Function}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  onCycleEnd: function(callback, context)\n  {\n    this.once( 'cycleEnd:' + this.cycleNext, callback, context );\n  }\n  \n};\n\n/**\n * Adds the following event methods to Animators: on, once, off, trigger.\n */\nanim8.eventize( anim8.Animator.prototype );\n\n/**\n * Provides the ability to defer method calls until certain events are triggered.\n */\nanim8.DeferAnimator = function(animator, previous, eventType, event)\n{\n\tthis.$reset( animator, previous, eventType, event );\n};\n\n/**\n * Creates the Defer prototype for the following Animator methods.\n */\nanim8.DeferAnimator.prototype = new anim8.Defer( anim8.DeferAnimator, \n[\n  'restore', 'placeAttrimator', 'preupdate', 'update', 'apply', 'trimAttrimators',\n  'activate', 'deactivate', 'destroy', 'spring', 'play', 'playAttrimators', 'queue',\n  'queueAttrimators', 'transition', 'transitionAttrimators', 'tween', 'tweenTo', \n  'tweenMany', 'tweenManyTo', 'follow', 'stop', 'end', 'finish', 'pause', 'resume',\n  'set', 'unset', 'get', 'invoke'\n]);\n","\n/*****************************************************************\n  ANIMATORS DEFINITION\n******************************************************************/\n\nanim8.Animators = function(input)\n{\n  if ( anim8.isArray( input ) )\n  {\n    this.fill( input );\n  }\n};\n\n/**\n * Animators is an instance of Array. All array methods are supported.\n */\nanim8.override( anim8s.fn = anim8.Animators.prototype = new Array(),\n{\n  /**\n   * Invokes a callback for each element in the array.\n   * \n   * @param {function} iterator\n   */\n  each: function(iterator, context) \n  {\n    for (var i = 0; i < this.length; i++) \n    {\n      if ( iterator.call( context || this[i], this[i], i ) === false ) \n      {\n        break;\n      }\n    }\n  \t\n  \treturn this;\n  },\n\n  /**\n   * Appends the array of animators given to the end of this array.\n   *\n   * @param {array} animators\n   */\n  fill: function(animators)\n  {\n    for (var i = 0; i < animators.length; i++)\n    {\n      this.push( animators[i] );\n    }\n\n    return this;\n  },\n\n  /**\n   * Invokes a callback for each element in the array and if true is returned that element is removed from the array.\n   *\n   * @param {function} filterer\n   */\n  filter: function(filterer)\n  {\t\n  \tvar alive = 0;\n  \t\n  \tfor (var i = 0; i < this.length; i++)\n  \t{\n  \t\tvar remove = filterer( this[i] );\n  \t\t\n  \t\tif ( !remove )\n  \t\t{\n  \t\t\tthis[alive++] = this[i];\n  \t\t}\n  \t}\n  \t\n  \tthis.length = alive;\n  \t\n  \treturn this;\n  },\n\n  /**\n   * Returns the subjects of the Animators optionally passing them through a wrapper\n   * function before it's returned.\n   *\n   * @param [function] wrapper\n   */\n  getSubjects: function(wrapper)\n  {\n    var subjects = [];\n\n    for (var i = 0; i < this.length; i++)\n    {\n      subjects.push( this[i].subject );\n    }\n\n    if ( anim8.isFunction( wrapper ) )\n    {\n      subjects = wrapper( subjects );\n    }\n    \n    return subjects;\n  },\n\n  /**\n   * Returns the first animator in the array.\n   */\n  first: function()\n  {\n    return this[0];\n  },\n\n  /**\n   * Reverses the order of animators in the array.\n   */\n  reverse: function()\n  {\n    var last = this.length - 1;\n    var mid = Math.floor( this.length / 2 );\n\n    for (var i = 0; i < mid; i++)\n    {\n      var e0 = this[ i ];\n      var e1 = this[ last - i ];\n\n      this[ i ] = e1;\n      this[ last - i ] = e0;\n    }\n\n    return this;\n  },\n\n  /**\n   * Activates all Animators in the array if they aren't active already.\n   * \n   * @return {this}\n   */\n  activate: function()\n  {\n    for (var i = 0; i < this.length; i++)\n    {\n      var animator = this[i];\n\n      if ( !animator.active )\n      {\n        animator.active = true;\n        anim8.animating.push( animator ); \n      }\n    }\n    \n    if ( !anim8.running )\n    {\n      anim8.running = true;\n      anim8.trigger('starting');\n      anim8.requestRun( anim8.run );\n    }\n    \n    return this;\n  },\n\n  /**\n   * Plays a sequence of events separated by a delay given an animation to play on all Animators.\n   */\n  sequence: function(delay, easing)\n  {\n    return new anim8.Sequence( this, delay, easing );\n  },\n\n  /**\n   * [timeRemaining description]\n   * @return {[type]}\n   */\n  timeRemaining: function()\n  {\n    var maxRemaining = 0;\n\n    for (var i = 0; i < this.length; i++)\n    {\n      maxRemaining = Math.max( maxRemaining, this[ i ].timeRemaining() );\n    }\n\n    return maxRemaining;\n  },\n\n  /**\n   * Adds the following methods to make an array of Animators appear like a single Animator.\n   */\n  restore               : anim8.delegate( 'restore', anim8.delegate.RETURN_THIS ),\n  placeAttrimator       : anim8.delegate( 'placeAttrimator', anim8.delegate.RETURN_THIS ),\n  preupdate             : anim8.delegate( 'preupdate', anim8.delegate.RETURN_THIS ),\n  update                : anim8.delegate( 'update', anim8.delegate.RETURN_THIS ),\n  apply                 : anim8.delegate( 'apply', anim8.delegate.RETURN_THIS ),\n  trimAttrimators       : anim8.delegate( 'trimAttrimators', anim8.delegate.RETURN_THIS ),\n  activate              : anim8.delegate( 'activate', anim8.delegate.RETURN_THIS ),\n  deactivate            : anim8.delegate( 'deactivate', anim8.delegate.RETURN_THIS ),\n  destroy               : anim8.delegate( 'destroy', anim8.delegate.RETURN_THIS ),\n  spring                : anim8.delegate( 'spring', anim8.delegate.RETURN_RESULTS ),\n  play                  : anim8.delegate( 'play', anim8.delegate.RETURN_THIS ),\n  playAttrimators       : anim8.delegate( 'playAttrimators', anim8.delegate.RETURN_THIS ),\n  queue                 : anim8.delegate( 'queue', anim8.delegate.RETURN_THIS ),\n  queueAttrimators      : anim8.delegate( 'queueAttrimators', anim8.delegate.RETURN_THIS ),\n  transition            : anim8.delegate( 'transition', anim8.delegate.RETURN_THIS ),\n  transitionAttrimators : anim8.delegate( 'transitionAttrimators', anim8.delegate.RETURN_THIS ),\n  tween                 : anim8.delegate( 'tween', anim8.delegate.RETURN_THIS ),\n  tweenTo               : anim8.delegate( 'tweenTo', anim8.delegate.RETURN_THIS ),\n  tweenMany             : anim8.delegate( 'tweenMany', anim8.delegate.RETURN_THIS ),\n  tweenManyTo           : anim8.delegate( 'tweenManyTo', anim8.delegate.RETURN_THIS ),\n  follow                : anim8.delegate( 'follow', anim8.delegate.RETURN_THIS ),\n  attrimatorsFor        : anim8.delegate( 'attrimatorsFor', anim8.delegate.RETURN_RESULTS ),\n  stop                  : anim8.delegate( 'stop', anim8.delegate.RETURN_THIS ),\n  end                   : anim8.delegate( 'end', anim8.delegate.RETURN_THIS ),\n  finish                : anim8.delegate( 'finish', anim8.delegate.RETURN_THIS ),\n  pause \t\t\t          : anim8.delegate( 'pause', anim8.delegate.RETURN_THIS ),\n  resume \t\t\t          : anim8.delegate( 'resume', anim8.delegate.RETURN_THIS ),\n  set                   : anim8.delegate( 'set', anim8.delegate.RETURN_THIS ),\n  unset                 : anim8.delegate( 'unset', anim8.delegate.RETURN_THIS ),\n  get                   : anim8.delegate( 'get', anim8.delegate.RETURN_FIRST ),\n  hasAttrimators        : anim8.delegate( 'hasAttrimators', anim8.delegate.RETURN_TRUE ),\n  invoke                : anim8.delegate( 'invoke', anim8.delegate.RETURN_THIS ),\n  on\t\t\t              : anim8.delegate( 'on', anim8.delegate.RETURN_THIS ),\n  once\t\t              : anim8.delegate( 'once', anim8.delegate.RETURN_THIS ),\n  off\t\t\t              : anim8.delegate( 'off', anim8.delegate.RETURN_THIS ),\n  trigger               : anim8.delegate( 'trigger', anim8.delegate.RETURN_THIS )\n\n});\n","\n/*****************************************************************\n  ANIM8 ANIMATION LOOP\n******************************************************************/\n\n/**\n * Whether the animation cycle is currently running. This is true\n * when where are active animators and anim8.run is being called\n * and false otherwise.\n */\nanim8.running = false;\n\n/**\n * Live Mode keeps the animation cycles running even when there aren't\n * Animators. For highly interactive applications enabling this may\n * take up more resources but it will result in smoother animations. When\n * the animation cycle goes from stopped to running it takes a few frames\n * to smooth out when this is false.\n */\nanim8.live = false;\n\n/**\n * The anim8 instance for all active animators.\n */\nanim8.animating = new anim8.Animators();\n\n/**\n * The function to call if animations need to be done.\n *\n * @param {function} callback\n */\nanim8.requestRun = (function() \n{  \n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  var requestor = window.requestAnimationFrame;\n  \n  for (var x = 0; x < vendors.length && !requestor; ++x) \n  {\n    requestor = window[ vendors[x] + 'RequestAnimationFrame' ];\n  }\n  \n  if (!requestor)\n  {\n    var lastTime = 0;\n    \n    return function(callback)\n    {\n      var now = anim8.now();\n      var timeToCall = Math.max( 0, 16 - (currTime - lastTime) );\n      var id = window.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n  \n  return function(callback)\n  {\n    requestor( callback );\n  };\n  \n})();\n\n/**\n * Adds an animator to the list if animating if it isn't there already. If the animation\n * loop isn't currently running it's started.\n * \n * @param {anim8.Animator} animator\n */\nanim8.add = function(animator)\n{\n  if ( !animator.active )\n  {\n    anim8.animating.push( animator );\n    \n    animator.active = true;\n  }\n  \n  if ( !anim8.running )\n  {\n    anim8.running = true;\n    anim8.trigger('starting');\n    anim8.requestRun( anim8.run );\n  }\n}\n\n/**\n * Executes an animation cycle which consists of four operations:\n *   1. Call preupdate on all Animators\n *   2. Call update on all Animators\n *   3. Call apply on all Animators\n *   4. Remove finished Animators\n * When there are no more animating the cycle is stopped.\n */\nanim8.run = function() \n{\n  anim8.trigger('begin');\n  \n  var now = anim8.now();\n  \n  // notify animators that we're about to update\n  anim8.animating.each(function(animator)\n  {\n    animator.preupdate( now );\n  });\n  \n  // update animating based on the current time\n  anim8.animating.each(function(animator)\n  {\n    animator.update( now );\n  });\n  \n  // apply the attributes calculated\n  anim8.animating.each(function(animator)\n  {\n    animator.apply();\n  });\n  \n  // if the animator is done remove it\n  anim8.animating.filter(function(animator)\n  {\n    if ( animator.finished )\n    {\n      animator.deactivate();\n      animator.active = false;\n    }\n    \n    return animator.finished;\n  });\n  \n  anim8.trigger('end');\n  \n  // if there are animators still remaining call me again!\n  if ( anim8.animating.length || anim8.live )\n  {\n    anim8.requestRun( anim8.run );\n  } \n  else \n  {\n    anim8.running = false;\n    anim8.trigger('finished');\n  }\n};\n\n/**\n * Add events to the animation cycle: begin, end, finished, starting\n */\nanim8.eventize( anim8 );\n","\n/**\n * [Sequence description]\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n */\nanim8.Sequence = function(animators, delay, easing)\n{\n  this.animators = animators;\n  this.delay = anim8.delay( delay );\n  this.easing = anim8.easing( easing );\n};\n\nanim8.Sequence.prototype =\n{\n  /**\n   * [maxDelay description]\n   * @return {[type]}\n   */\n  maxDelay: function()\n  {\n    return this.delay * (this.animators.length - 1);\n  },\n  \n  /**\n   * [createEvents description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  createAttrimators: function(animation, options, i)\n  {\n    var attrimatorMap = animation.newAttrimators();\n    var attrimators = attrimatorMap.values;\n    var delta = i / (this.animators.length - 1);\n    var delayOffset = this.easing( delta ) * this.maxDelay();\n    \n    for (var k = attrimators.length - 1; k >= 0; k--)\n    {\n      attrimators[ k ].delay += delayOffset;\n    }\n\n    animation.merge( options, attrimatorMap );\n    \n    return attrimatorMap;\n  },\n\n  /**\n   * [reverse description]\n   * @return {[type]}\n   */\n  reverse: function()\n  {\n    this.animators.reverse();\n\n    return this;\n  },\n  \n  /**\n   * [play description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  play: function(animation, options, all, cache)\n  {\n    var options = anim8.options( options );\n    var anim = anim8.animation( animation, options, cache );\n\n    if ( anim === false )\n    {\n      return this;\n    }\n\n    var sequence = this;\n\n    this.animators.each(function(animator, i)\n    {\n      var attrimators = sequence.createAttrimators( anim, options, i );\n      animator.newCycle( attrimators );\n      animator.playAttrimators( attrimators, all );       \n    });\n    \n    return this.add();\n  },\n  \n  /**\n   * [queue description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  queue: function(animation, options, cache)\n  {\n    var options = anim8.options( options );\n    var anim = anim8.animation( animation, options, cache );\n\n    if ( anim === false )\n    {\n      return this;\n    }\n\n    var sequence = this;\n    var maxRemaining = 0;\n    var remaining = [];\n    \n    this.animators.each(function(animator, i)\n    {\n      remaining[i] = animator.timeRemaining();\n      maxRemaining = Math.max( maxRemaining, remaining[i] );\n    });\n\n    this.animators.each(function(animator, i)\n    {\n      var delayOffset = maxRemaining - remaining[i];\n      var attrimatorMap = sequence.createAttrimators( anim, options, i );\n      var attrimators = attrimatorMap.values;\n\n      for (var k = attrimators.length - 1; k >= 0; k--)\n      {\n        attrimators[ k ].delay += delayOffset;\n      }\n      \n      animator.newCycle( attrimatorMap );\n      animator.queueAttrimators( attrimatorMap );\n    });\n    \n    return this.add();\n  },\n\n  /**\n   * [transition description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  transition: function(transition, animation, options, all, cache)\n  {\n    var transition = anim8.transition( transition );\n    var options = anim8.options( options );\n    var anim = anim8.animation( animation, options, cache );\n\n    if ( anim === false )\n    {\n      return this;\n    }\n\n    var sequence = this;\n\n    this.animators.each(function(animator, i)\n    {\n      var attrimators = sequence.createAttrimators( anim, options, i );\n      animator.newCycle( attrimators );\n      animator.transitionAttrimators( transition, attrimators, all );\n    });\n    \n    return this.add();\n  },\n  \n  /**\n   * [add description]\n   */\n  add: function()\n  {\n    this.animators.activate();\n    \n    return this;\n  }\n  \n};","\n/**\n * Returns a parser based on the input. If the input is a function that function is immediately returned.\n * If the input is a string the parser with that name is returned. If no parser could be determined then\n * false is returned.\n * \n * @param {function|string} parser\n */\nanim8.parser = function(parser)\n{\n  if ( parser instanceof anim8.Parser )\n  {\n    return parser;\n  }\n\tif ( anim8.isString( parser ) && parser in anim8.parser )\n\t{\n\t\treturn anim8.parser[ parser ];\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Instantiates a new Parser.\n */\nanim8.Parser = function()\n{\n  \n};\n\nanim8.Parser.prototype = \n{\n  \n  /**\n   * Parses the animation object (and optionally an option object) and pushes\n   * all generated attrimatorMap to the given array.\n   * \n   * @param {object} animation\n   * @param {object} options\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  parse: function( animation, options, attrimatorMap, helper )\n  {\n    throw 'Parser.parse not implemented';\n  },\n  \n  /**\n   * Merges the options with the given event instances. This is when an existing \n   * animation is provided but the user wants to override the animation's options.\n   *\n   * Because event properties can be specified in several places there's a priority\n   * to which one takes precedence. The properties specified in the animation object\n   * itself are highest priority, followed by the new options, then by the old\n   * options, and finally by the existing property on the event instance.\n   *\n   * @param {object} animation\n   * @param {object} newOptions\n   * @param {object} oldOptions\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  merge: function( animation, newOptions, oldOptions, attrimatorMap, helper )\n  { \n    var factory = anim8.factory( animation.factory );\n    var attrimators = attrimatorMap.values;\n\n    for (var i = attrimators.length - 1; i >= 0; i--)\n    {\n      var e = attrimators[ i ];\n      var attr = e.attribute;\n      \n      if ( e.getParser() !== this )\n      {\n        continue;\n      }\n\n      e.easing    = helper.mergeEasing( attr, e.easing );\n      e.repeat    = helper.mergeRepeat( attr, e.repeat );\n      e.delay     = helper.mergeDelay( attr, e.delay );\n      e.sleep     = helper.mergeSleep( attr, e.sleep );\n      e.duration  = helper.mergeDuration( attr, e.duration );\n      e.scale     = helper.mergeScale( attr, e.scale );\n      e.scaleBase = helper.mergeScaleBase( attr, e.scaleBase, factory );\n    }\n  }\n};\n\n\n/**\n * [ParserHelper description]\n * @param {[type]}\n * @param {[type]}\n * @param {[type]}\n */\nanim8.ParserHelper = function( input, oldOptions, newOptions )\n{\n  this.input = input;\n  this.oldOptions = oldOptions || {};\n  this.newOptions = newOptions || {};\n\n  this.prepareSpecifics( 'easings' );\n  this.prepareSpecifics( 'repeats' );\n  this.prepareSpecifics( 'delays' );\n  this.prepareSpecifics( 'sleeps' );\n  this.prepareSpecifics( 'durations' );\n  this.prepareSpecifics( 'scales' );\n  this.prepareSpecifics( 'scaleBases' );\n};\n\nanim8.ParserHelper.prototype = \n{\n\n  /**\n   * [prepareSpecifics description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  prepareSpecifics: function(specifics)\n  {\n    if ( !anim8.isObject( this.input[ specifics ] ) )\n    {\n      this.input[ specifics ] = {};\n    }\n  },\n\n  /* PARSING */\n\n  /**\n   * [parseEasing description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  parseEasing: function(attr)\n  {\n    return this.parseFirst( attr, 'easing', 'easings' );\n  },\n\n  /**\n   * [parseRepeat description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  parseRepeat: function(attr)\n  {\n    return this.parseNumber( attr, anim8.repeat, anim8.repeat, 'repeat', 'repeatAdd', 'repeatScale', 'repeats' );\n  },\n\n  /**\n   * [parseDelay description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  parseDelay: function(attr)\n  {\n    return this.parseNumber( attr, anim8.delay, anim8.time, 'delay', 'delayAdd', 'delayScale', 'delays' );\n  },\n\n  /**\n   * [parseSleep description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  parseSleep: function(attr)\n  {\n    return this.parseNumber( attr, anim8.sleep, anim8.time, 'sleep', 'sleepAdd', 'sleepScale', 'sleeps' );\n  },\n\n  /**\n   * [parseDuration description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  parseDuration: function(attr)\n  {\n    return this.parseNumber( attr, anim8.duration, anim8.time, 'duration', 'durationAdd', 'durationScale', 'durations' );\n  },\n\n  /**\n   * [parseScale description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  parseScale: function(attr)\n  {\n    return this.parseNumber( attr, anim8.scale, anim8.number, 'scale', 'scaleAdd', 'scaleScale', 'scales' );\n  },\n\n  /**\n   * [parseScaleBase description]\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  parseScaleBase: function(attr)\n  {\n    return this.parseFirst( attr, 'scaleBase', 'scaleBases' );\n  },\n\n  /**\n   * [parseFirst description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  parseFirst: function(attr, option, specifics)\n  {\n    return anim8.coalesce( this.input[ specifics ][ attr ], this.oldOptions[ option ] );\n  },\n\n  /**\n   * [parseEvent description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {Boolean}\n   * @return {[type]}\n   */\n  parseEvent: function(attr, path, parser, hasInitialState)\n  {\n    var duration   = this.parseDuration( attr );\n    var easing     = this.parseEasing( attr );\n    var delay      = this.parseDelay( attr );\n    var sleep      = this.parseSleep( attr );\n    var repeat     = this.parseRepeat( attr );\n    var scale      = this.parseScale( attr );\n    var scaleBase  = this.parseScaleBase( attr );\n    var event      = new anim8.Event( attr, path, duration, easing, delay, sleep, repeat, scale, scaleBase, hasInitialState, parser );\n\n    return event;\n  },\n\n  /**\n   * [parseNumber description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  parseNumber: function(attr, parseFunction, parseOptionFunction, option, optionAdd, optionScale, specifics)\n  {\n    var baseRaw = anim8.coalesce( this.input[ specifics ][ attr ], this.oldOptions[ option ] );\n    var base = parseFunction( baseRaw );\n    var add = parseOptionFunction( this.oldOptions[ optionAdd ], 0 );\n    var scale = anim8.coalesce( this.oldOptions[ optionScale ], 1 );\n\n    return (add === 0 && scale === 1) ? baseRaw : (base + add) * scale;\n  },\n\n  /* MERGING */\n\n  /**\n   * [mergeEasing description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  mergeEasing: function(attr, current)\n  {\n    return this.mergeFirst( attr, current, anim8.easing, 'easing', 'easings' );\n  },\n\n  /**\n   * [mergeRepeat description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  mergeRepeat: function(attr, current)\n  {\n    return this.mergeNumber( attr, current, anim8.repeat, 'repeat', 'repeatAdd', 'repeatScale', 'repeats' );\n  },\n\n  /**\n   * [mergeDelay description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  mergeDelay: function(attr, current)\n  {\n    return this.mergeNumber( attr, current, anim8.time, 'delay', 'delayAdd', 'delayScale', 'delays' );\n  },\n\n  /**\n   * [mergeSleep description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  mergeSleep: function(attr, current)\n  {\n    return this.mergeNumber( attr, current, anim8.time, 'sleep', 'sleepAdd', 'sleepScale', 'scales' );\n  },\n\n  /**\n   * [mergeDuration description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  mergeDuration: function(attr, current)\n  {\n    return this.mergeNumber( attr, current, anim8.time, 'duration', 'durationAdd', 'durationScale', 'durations' );\n  },\n\n  /**\n   * [mergeScale description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  mergeScale: function(attr, current)\n  {\n    return this.mergeNumber( attr, current, anim8.number, 'scale', 'scaleAdd', 'scaleScale', 'scales' );\n  },\n\n  /**\n   * [mergeScaleBase description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  mergeScaleBase: function(attr, current, factory)\n  {\n    var calc = factory.attribute( attr ).calculator;\n    var parseFunction = function(value, defaultValue) {\n      return calc.parse( value, defaultValue );\n    };\n\n    return this.mergeFirst( attr, current, parseFunction, 'scaleBase', 'scaleBases' );\n  },\n\n  /**\n   * [mergeFirst description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  mergeFirst: function(attr, current, parseOptionFunction, option, specifics)\n  {\n    return parseOptionFunction( anim8.coalesce( this.input[ specifics ][ attr ], this.newOptions[ option ], this.oldOptions[ option ] ), current );\n  },\n\n  /**\n   * [mergeNumber description]\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @param  {[type]}\n   * @return {[type]}\n   */\n  mergeNumber: function(attr, current, parseOptionFunction, option, optionAdd, optionScale, specifics)\n  {\n    var baseRaw = anim8.coalesce( this.input[ specifics ][ attr ], this.newOptions[ option ], this.oldOptions[ option ] );\n    var base = parseOptionFunction( baseRaw, current );\n    var add = parseOptionFunction( anim8.coalesce( this.newOptions[ optionAdd ], this.oldOptions[ optionAdd ] ), 0 );\n    var scale = anim8.coalesce( this.newOptions[ optionScale ], this.oldOptions[ optionScale ], 1 );\n\n    return (base + add) * scale;\n  }\n\n};","\n/**\n * Instantiates a new parser for the 'deltas' & 'values' animation type.\n */\nanim8.ParserDeltas = function()\n{\n  \n};\n\n// ParserDeltas extends anim8.Parser()\nanim8.override( anim8.ParserDeltas.prototype = new anim8.Parser(),\n{\n\n  /**\n   * Parses the animation object (and optionally an option object) and pushes\n   * all generated attrimators to the given array.\n   * \n   * @param {object} animation\n   * @param {object} options\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  parse: function( animation, options, attrimatorMap, helper )\n  {\n    // 1. If deltas wasn't specified, assume a uniform distribution of points\n    // 2. If deltas was an array, expand out into an object where the keys are attributes and the value is the delta array\n    // 3. Generate the attrimators\n    \n    var factory = anim8.factory( animation.factory );\n  \tvar deltas = animation.deltas;\n  \tvar values = animation.values;\n\n    if ( !anim8.isDefined( deltas ) )\n    {\n      var valueCount = 0;\n      \n  \t\tfor (var attr in values)\n  \t\t{\n        valueCount++; \n      }\n      \n      deltas = [];\n      \n      for (var i = 0; i < valueCount; i++)\n      {\n        deltas[i] = i / (valueCount - 1);\n      }\n    }\n  \tif ( anim8.isArray( deltas ) )\n  \t{\n  \t\tvar deltaObject = {};\n  \t\t\n  \t\tfor (var attr in values)\n  \t\t{\n  \t\t\tdeltaObject[attr] = deltas;\t\n  \t\t}\n  \t\t\n  \t\tdeltas = deltaObject;\n  \t}\n    \n  \tfor (var attr in values)\n  \t{\n  \t\tvar value = values[ attr ];\n      var attribute = factory.attribute( attr );\n  \t\t\n  \t\tfor (var k = 0; k < value.length; k++)\n  \t\t{\n  \t\t\tvalue[k] = attribute.parse( value[k] );\n  \t\t}\n\n      var path      = new anim8.DeltaPath( attr, attribute.calculator, values[ attr ], deltas[ attr ] );\n      var event     = helper.parseEvent( attr, path, this, true );\n      \n      attrimatorMap.put( attr, event );\n  \t}\n  }\n  \n});\n\n/**\n * Register the parser.\n */\nanim8.parser['values'] = new anim8.ParserDeltas();\n","\n/**\n * Instantiates a new parser for the 'final' animation type.\n */\nanim8.ParserFinal = function()\n{\n  \n};\n\n// ParserFinal extends anim8.Parser()\nanim8.override( anim8.ParserFinal.prototype = new anim8.Parser(),\n{\n    \n  /**\n   * Parses the animation object (and optionally an option object) and pushes\n   * all generated attrimators to the given array.\n   * \n   * @param {object} animation\n   * @param {object} options\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  parse: function( animation, options, attrimatorMap, helper )\n  {\n    // 1. Generate the attrimators, only caring about the delays and durations\n    \n    var factory = anim8.factory( animation.factory );\n  \tvar values = animation.final;\n    \n  \tfor (var attr in values)\n  \t{\n      var attribute  = factory.attribute( attr );\n      var value      = attribute.parse( values[ attr ] );\n      var delay      = anim8.delay( helper.parseDelay( attr ) );\n      var duration   = anim8.duration( helper.parseDuration( attr ) );\n      var scale      = helper.parseScale( attr );\n      var scaleBase  = helper.parseScaleBase( attr );\n      var path       = new anim8.PointPath( attr, attribute.calculator, value );\n      var event      = new anim8.Event( attr, path, 0, anim8.easing.default, delay + duration, 0, 1, scale, scaleBase, false, this );\n      \n      attrimatorMap.put( attr, event );\n  \t}\n  },\n\n  /**\n   * Merges the options with the given event instances. This is when an existing \n   * animation is provided but the user wants to override the animation's options.\n   *\n   * Because event properties can be specified in several places there's a priority\n   * to which one takes precedence. The properties specified in the animation object\n   * itself are highest priority, followed by the new options, then by the old\n   * options, and finally by the existing property on the event instance.\n   *\n   * @param {object} animation\n   * @param {object} newOptions\n   * @param {object} oldOptions\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  merge: function( animation, newOptions, oldOptions, attrimatorMap, helper )\n  {\n    var factory = anim8.factory( animation.factory );\n    var attrimators = attrimatorMap.values;\n\n    for (var i = attrimators.length - 1; i >= 0; i--)\n    {\n      var e = attrimators[i];\n      var attr = e.attribute;\n        \n      if ( e.getParser() !== this )\n      {\n        continue;\n      }\n\n      e.delay     = helper.mergeDelay( attr, e.delay ) + helper.mergeDuration( attr, e.duration );\n      e.scale     = helper.mergeScale( attr, e.scale );\n      e.scaleBase = helper.mergeScaleBase( attr, e.scaleBase, factory ); \n    }\n  }\n\n});\n\n/**\n * Register the parser.\n */\nanim8.parser['final'] = new anim8.ParserFinal();\n\n","\n/**\n * Instantiates a new parser for the 'initial' animation type.\n */\nanim8.ParserInitial = function()\n{\n  \n};\n\n// ParserInitial extends anim8.Parser()\nanim8.override( anim8.ParserInitial.prototype = new anim8.Parser(),\n{\n    \n  /**\n   * Parses the animation object (and optionally an option object) and pushes\n   * all generated attrimators to the given array.\n   * \n   * @param {object} animation\n   * @param {object} options\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  parse: function( animation, options, attrimatorMap, helper )\n  {\n    // 1. Generate the attrimators, only caring about the delays\n    \n    var factory    = anim8.factory( animation.factory );\n  \tvar values     = animation.initial;\n    \n  \tfor (var attr in values)\n  \t{\n      var attribute  = factory.attribute( attr );\n      var value      = attribute.parse( values[ attr ] ); \n      var delay      = helper.parseDelay( attr );\n      var scale      = helper.parseScale( attr );\n      var scaleBase  = helper.parseScaleBase( attr );\n      var path       = new anim8.PointPath( attr, attribute.calculator, value );\n      var event      = new anim8.Event( attr, path, 0, anim8.easing.default, delay, 0, 1, scale, scaleBase, true, this );\n      \n      attrimatorMap.put( attr, event );\n  \t}\n  },\n\n  /**\n   * Merges the options with the given event instances. This is when an existing \n   * animation is provided but the user wants to override the animation's options.\n   *\n   * Because event properties can be specified in several places there's a priority\n   * to which one takes precedence. The properties specified in the animation object\n   * itself are highest priority, followed by the new options, then by the old\n   * options, and finally by the existing property on the event instance.\n   *\n   * @param {object} animation\n   * @param {object} newOptions\n   * @param {object} oldOptions\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  merge: function( animation, newOptions, oldOptions, attrimatorMap, helper )\n  {\n    var factory    = anim8.factory( animation.factory );\n    var attrimators = attrimatorMap.values;\n\n    for (var i = attrimators.length - 1; i >= 0; i--)\n    {\n      var e = attrimators[i];\n      var attr = e.attribute;\n        \n      if ( e.getParser() !== this )\n      {\n        continue;\n      }\n      \n      e.delay     = helper.mergeDelay( attr, e.delay );\n      e.scale     = helper.mergeScale( attr, e.scale );\n      e.scaleBase = helper.mergeScaleBase( attr, e.scaleBase, factory );\n    }\n  }\n  \n});\n\n/**\n * Register the parser.\n */\nanim8.parser['initial'] = new anim8.ParserInitial();\n","\n/**\n * Instantiates a new parser for the 'keyframe' animation type.\n */\nanim8.ParserKeyframe = function()\n{\n  \n};\n\n// ParserKeyframe extends anim8.Parser()\nanim8.override( anim8.ParserKeyframe.prototype = new anim8.Parser(),\n{\n  \n  /**\n   * Parses the animation object (and optionally an option object) and pushes\n   * all generated attrimators to the given array.\n   * \n   * @param {object} animation\n   * @param {object} options\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  parse: function( animation, options, attrimatorMap, helper )\n  {\n    // 1. Normalize keys by converting aliases to the actual value\n    // 2. Split up keys that have commas into multiple entries\n    // 3. Validate keys and remove invalid ones - also calculate max key value\n    // 4. Sort frames by the key\n    // 5. Expand frames to generate delta arrays, value arrays, and easing arrays\n    // 6. Generate the attrimators\n    \n    var factory = anim8.factory( animation.factory );\n    var kframes = animation.keyframe;\n    var easings = animation.easings || {};\n    var teasing = anim8.easing( anim8.coalesce( options.teasing, anim8.defaults.teasing ) );\n    \n    var sort = false;\n    \n    var aliases = {\n      from:     '0',\n      start:    '0',\n      initial:  '0',\n      first:    '0',\n      half:     '50',\n      middle:   '50',\n      to:       '100',\n      end:      '100',\n      last:     '100'\n    };\n    \n    // split up comma delimited times\n    for (var time in kframes)\n    {\n      if ( time in aliases )\n      {\n        kframes[ aliases[time] ] = kframes[ time ];\n        \n        delete kframes[ time ];\n      }\n      else if ( time.indexOf(',') !== -1 )\n      {\n        var times = time.split(',');\n        \n        for (var i = 0; i < times.length; i++)\n        {\n          kframes[times[i]] = kframes[time];\n        }\n        \n        delete kframes[time];\n        \n        sort = true;\n      }\n    }\n    \n    var times = [];\n    \n    // validate times\n    var lastTime = 0.0;\n    var maxTime = 0.0;\n    \n    for (var time in kframes)\n    {\n      var t = parseFloat(time);\n      \n      if (isNaN(t))\n      {\n        delete kframes[time];\n      }\n      else\n      {\n        if (t < lastTime)\n        {\n          sort = true;\n        }\n        \n        times.push({\n          order: t,\n          key: time,\n          value: kframes[time]\n        });\n        \n        lastTime = t;\n        \n        maxTime = Math.max( maxTime, t );\n      }\n    }\n    \n    // sort if necessary\n    if (sort)\n    {\n      times.sort(function(a, b) \n      {\n        return a.order - b.order;\n      });\n      \n      kframes = {};\n      \n      for (var i = 0; i < times.length; i++)\n      {\n        kframes[times[i].key] = times[i].value;\n      }\n    }\n    \n    // split up into deltas and values\n    var deltas = {};\n    var values = {};\n    var pathEasings = {};\n    var attributes = {};\n    \n    for (var i = 0; i < times.length; i++)\n    {\n      var frame = times[i];\n      var easing = anim8.coalesce( frame.value.easing, options.easing );\n      \n      delete frame.value.easing;\n      \n      for (var attr in frame.value)\n      {\n        if ( !(attr in deltas) )\n        {\n          deltas[attr] = [];\n          values[attr] = [];\n          pathEasings[attr] = [];\n          attributes[attr] = factory.attribute( attr );\n        }\n  \t\t\t\n        deltas[attr].push( frame.order / maxTime );\n        values[attr].push( attributes[ attr ].parse( frame.value[ attr ] ) );\n        pathEasings[attr].push( anim8.easing( anim8.coalesce( easings[ attr ], easing ) ) );\n      }\n    }\n  \t\n    // create events & paths\n    for (var attr in deltas)\n    {\n      var duration  = helper.parseDuration( attr );\n      var delay     = helper.parseDelay( attr );\n      var sleep     = helper.parseSleep( attr );\n      var repeat    = helper.parseRepeat( attr );\n      var scale     = helper.parseScale( attr );\n      var scaleBase = helper.parseScaleBase( attr );\n      var path      = new anim8.KeyframePath( attr, attributes[attr].calculator, values[attr], deltas[attr], pathEasings[attr] );\n      var event     = new anim8.Event( attr, path, duration, teasing, delay, sleep, repeat, scale, scaleBase, true, this );\n      \n      attrimatorMap.put( attr, event );\n    }\n  }\n});\n\n/**\n * Registers the parser.\n */\nanim8.parser['keyframe'] = new anim8.ParserKeyframe();\n","\n/**\n * Instantiates a new parser for the 'tweenTo' animation type.\n */\nanim8.ParserTweenTo = function()\n{\n  \n};\n\n// ParserTweenTo extends anim8.Parser()\nanim8.override( anim8.ParserTweenTo.prototype = new anim8.Parser(),\n{\n    \n  /**\n   * Parses the animation object (and optionally an option object) and pushes\n   * all generated attrimators to the given array.\n   * \n   * @param {object} animation\n   * @param {object} options\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  parse: function( animation, options, attrimatorMap, helper )\n  {\n    // 1. Starting values are all true which signals to Animator to replace those points with the animator's current values.\n\n    var factory    = anim8.factory( animation.factory );\n    var tweenTo    = animation.tweenTo;\n\n  \tfor (var attr in tweenTo)\n  \t{\n      var attribute  = factory.attribute( attr );\n      var value      = attribute.parse( tweenTo[ attr ] );\n      var path       = new anim8.Tween( attr, attribute.calculator, anim8.computed.current, value );\n      var event      = helper.parseEvent( attr, path, this, true );\n      \n      attrimatorMap.put( attr, event );\n  \t}\n  }\n});\n\n/**\n * Register the parser.\n */\nanim8.parser['tweenTo'] = new anim8.ParserTweenTo();\n","\n/**\n * Instantiates a new parser for the 'tweenFrom' animation type.\n */\nanim8.ParserTweenFrom = function()\n{\n  \n};\n\n// ParserTweenFrom extends anim8.Parser()\nanim8.override( anim8.ParserTweenFrom.prototype = new anim8.Parser(),\n{\n    \n  /**\n   * Parses the animation object (and optionally an option object) and pushes\n   * all generated attrimators to the given array.\n   * \n   * @param {object} animation\n   * @param {object} options\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  parse: function( animation, options, attrimatorMap, helper )\n  {\n    // 1. Starting values are all true which signals to Animator to replace those points with the animator's current values.\n\n    var factory    = anim8.factory( animation.factory );\n    var tweenFrom  = animation.tweenFrom;\n\n  \tfor (var attr in tweenFrom)\n  \t{\n      var attribute  = factory.attribute( attr );\n      var value      = attribute.parse( tweenFrom[ attr ] );\n      var path       = new anim8.Tween( attr, attribute.calculator, value, anim8.computed.current );\n      var event      = helper.parseEvent( attr, path, this, true );\n      \n      attrimatorMap.put( attr, event );\n  \t}\n  }\n});\n\n/**\n * Register the parser.\n */\nanim8.parser['tweenFrom'] = new anim8.ParserTweenFrom();\n","\n/**\n * Instantiates a new parser for the 'move' animation type.\n */\nanim8.ParserMove = function()\n{\n  \n};\n\n// ParserMove extends anim8.Parser()\nanim8.override( anim8.ParserMove.prototype = new anim8.Parser(),\n{\n    \n  /**\n   * Parses the animation object (and optionally an option object) and pushes\n   * all generated attrimators to the given array.\n   * \n   * @param {object} animation\n   * @param {object} options\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  parse: function( animation, options, attrimatorMap, helper )\n  {\n    // 1. Starting values are all true which signals to Animator to replace those points with the animator's current values.\n\n    var factory    = anim8.factory( animation.factory );\n    var move       = animation.move;\n\n  \tfor (var attr in move)\n  \t{\n      var attribute  = factory.attribute( attr );\n      var value      = attribute.parse( move[ attr ] );\n      var path       = new anim8.Tween( attr, attribute.calculator, anim8.computed.current, anim8.computed.relative( value ) );\n      var event      = helper.parseEvent( attr, path, this, true );\n      \n      attrimatorMap.put( attr, event );\n  \t}\n  }\n});\n\n/**\n * Register the parser.\n */\nanim8.parser['move'] = new anim8.ParserMove();\n","\n/**\n * Instantiates a new parser for the 'move' animation type.\n */\nanim8.ParseSpring = function()\n{\n  \n};\n\n// ParseSpring extends anim8.Parser()\nanim8.override( anim8.ParseSpring.prototype = new anim8.Parser(),\n{\n    \n  /**\n   * Parses the animation object (and optionally an option object) and pushes\n   * all generated attrimators to the given array.\n   * \n   * @param {object} animation\n   * @param {object} options\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  parse: function( animation, options, attrimatorMap, helper )\n  {\n    var factory    = anim8.factory( animation.factory );\n    var springs    = animation.springs;\n\n  \tfor (var attr in springs)\n  \t{\n      var spring     = springs[ attr ];\n\n      if ( !anim8.isDefined( spring.attribute ) )\n      {\n        spring.attribute = attr;\n      }\n\n      var parsed = anim8.spring( spring );\n      \n      if ( parsed !== false )\n      {\n        parsed.parser = this;\n\n        attrimatorMap.put( attr, parsed );  \n      }\n  \t}\n  }\n});\n\n/**\n * Register the parser.\n */\nanim8.parser['springs'] = new anim8.ParseSpring();\n","\n/**\n * Instantiates a new parser for the 'move' animation type.\n */\nanim8.ParsePhysics = function()\n{\n  \n};\n\n// ParsePhysics extends anim8.Parser()\nanim8.override( anim8.ParsePhysics.prototype = new anim8.Parser(),\n{\n    \n  /**\n   * Parses the animation object (and optionally an option object) and pushes\n   * all generated attrimators to the given array.\n   * \n   * @param {object} animation\n   * @param {object} options\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  parse: function( animation, options, attrimatorMap, helper )\n  {\n    var factory    = anim8.factory( animation.factory );\n    var physics    = animation.physics;\n\n  \tfor (var attr in physics)\n  \t{\n      var physic    = physics[ attr ];\n\n      var attrimator = new anim8.Physics(\n        attr, \n        this, \n        physic.calculator, \n        anim8.coalesce( physic.position, true ), \n        physic.velocity, \n        physic.acceleration, \n        physic.terminal,\n        physic.stopAt\n      );\n\n      attrimatorMap.put( attr, attrimator );\n  \t}\n  }\n});\n\n/**\n * Register the parser.\n */\nanim8.parser['physics'] = new anim8.ParsePhysics();\n","\n/**\n * Instantiates a new parser for the 'move' animation type.\n */\nanim8.ParserTravel = function()\n{\n  \n};\n\n// ParserTravel extends anim8.Parser()\nanim8.override( anim8.ParserTravel.prototype = new anim8.Parser(),\n{\n    \n  /**\n   * Parses the animation object (and optionally an option object) and pushes\n   * all generated attrimators to the given array.\n   * \n   * @param {object} animation\n   * @param {object} options\n   * @param {anim8.AttrimatorMap} attrimatorMap\n   * @param {anim8.ParserHelper} helper\n   */\n  parse: function( animation, options, attrimatorMap, helper )\n  {\n    // 1. Starting values are all true which signals to Animator to replace those points with the animator's current values.\n\n    var factory    = anim8.factory( animation.factory );\n    var travel     = animation.travel;\n\n    /**\n     * The computed function which returns a function which returns a value pointing\n     * to a given target given the current position of the animator.\n     * \n     * @param  {Number}\n     * @param  {any}\n     * @param  {Number}\n     * @return {Function}\n     */\n    var pointing = function(amount, target, epsilon, subtractVelocity)\n    {\n      var pointingFunction = function(attrimator, animator)\n      {\n        var attribute = animator.getAttribute( attrimator.attribute );\n        var calc = attribute.calculator;\n        var targetValue = anim8.isComputed( target ) ? target( attrimator, animator ) : target;\n        var temp = calc.create();\n\n        return function()\n        {\n          var position   = attrimator.position;\n          var current    = calc.copy( temp, anim8.resolve( targetValue ) );\n          var difference = calc.sub( current, position );\n          var distance   = calc.distance( difference, calc.ZERO );\n\n          if ( distance < epsilon )\n          {\n            attrimator.stopIn( 0 );\n          }\n          else\n          {\n            difference = calc.scale( difference, amount / distance );\n          }\n          \n          if ( subtractVelocity )\n          {\n            difference = calc.sub( difference, attrimator.resolveVelocity() );\n          }\n\n          return difference;\n        };\n      };\n\n      pointingFunction.computed = true;\n\n      return pointingFunction;\n    };\n\n  \tfor (var attr in travel)\n  \t{\n      var traveling     = travel[ attr ];\n      var attribute     = factory.attribute( attr );\n      var from          = attribute.parse( anim8.coalesce( traveling.from, true ) );\n      var to            = attribute.parse( anim8.coalesce( traveling.to, true ) );\n      var velocity      = anim8.number( traveling.velocity, 0 );\n      var acceleration  = anim8.number( traveling.acceleration, 0 );\n      var terminal      = anim8.number( anim8.coalesce( traveling.terminal, traveling.velocity ), Number.POSITIVE_INFINITY );\n      var epsilon       = anim8.number( traveling.epsilon, 0.001 );\n\n      if ( acceleration !== 0 )\n      {\n        acceleration = pointing( acceleration, to, epsilon, true );\n      }\n\n      if ( velocity !== 0 )\n      {\n        velocity = pointing( velocity, to, epsilon, false );\n      }\n\n      var traveler = new anim8.Physics(\n        attr,\n        this,\n        attribute.calculator,\n        from,\n        velocity,\n        acceleration,\n        terminal\n      );\n      \n      attrimatorMap.put( attr, traveler );\n  \t}\n  }\n});\n\n/**\n * Register the parser.\n */\nanim8.parser['travel'] = new anim8.ParserTravel();\n","\n\n/**\n * Returns a factory for the given subject or throws an error if no factory exists.\n *\n * @param {any} subject\n */\nanim8.factoryFor = function(subject, optional) \n{\n  var highestPriorityFactory = false;\n\n  for (var factoryName in anim8.factory) \n  {\n    var factory = anim8.factory[ factoryName ];\n    \n    if ( factory.is( subject ) && (highestPriorityFactory === false || highestPriorityFactory.priority < factory.priority) )\n    {     \n      highestPriorityFactory = factory;\n    }\n  }\n  \n  if ( highestPriorityFactory )\n  {\n    return highestPriorityFactory;\n  }\n\n  if ( optional )\n  {\n    return false;\n  }\n  \n  throw 'No factory exists for subject ' + subject;\n};\n\n/**\n * Returns a factory given the input and returns the default if none is found.\n * \n * @param  [string|anim8.Factory]\n * @return {anim8.Factory}\n */\nanim8.factory = function(factory)\n{\n  if ( factory instanceof anim8.Factory )\n  {\n    return factory;\n  }\n  if ( anim8.isString( factory ) && factory in anim8.factory )\n  {\n    return anim8.factory[ factory ];\n  }\n\n  return anim8.factory.default;\n};\n\n/**\n * A factory creates Animator instances for subjects.\n */\nanim8.Factory = function()\n{\n  this.priority = 0;\n};\n\nanim8.Factory.prototype = \n{\n\n  /**\n   * Determines whether the given subject is valid for this factory to create Animators for.\n   * \n   * @param  {any} subject\n   * @return {boolean}\n   */\n  is: function(subject)\n  {\n    throw 'Factory.is not implemented';\n  },\n\n  /**\n   * Returns an animator given a subject.\n   * \n   * @param  {any} subject\n   * @return {anim8.Animator}\n   */\n  animatorFor: function(subject)\n  {\n    throw 'Factory.animatorFor not implemented';\n  },\n\n  /**\n   * Explodes the given subject to an array of Animators and adds them to the given array.\n   * \n   * @param  {any} subject\n   * @param  {array} animators\n   * @return {void}\n   */\n  animatorsFor: function(subject, animators)\n  {\n    animators.push( this.animatorFor( subject ) );\n  },\n\n  /**\n   * Destroys the animator by unlinking the animator from the subject.\n   * \n   * @param  {anim8.Animator} animator\n   * @return {void}\n   */\n  destroy: function(animator)\n  {\n\n  },\n\n  /**\n   * Returns the attribute descriptor for the given attribute.\n   * \n   * @param  {string} attr\n   * @return {object}\n   */\n  attribute: function(attr)\n  {\n    throw 'Factory.attribute not implemented';\n  }\n\n};\n","\n/**\n * A factory for plain objects.\n */\nanim8.ObjectFactory = function()\n{\n  this.priority = 0;\n  this.attributes = {};\n};\n\nanim8.override( anim8.ObjectFactory.prototype = new anim8.Factory(),\n{\n  /**\n   * Determines whether the given subject is valid for this factory to create Animators for.\n   * \n   * @param  {any} subject\n   * @return {boolean}\n   */\n  is: function(subject)\n  {\n    return anim8.isObject( subject ) && !anim8.isElement( subject ) && !anim8.isArray( subject );\n  },\n\n  /**\n   * Returns an animator given a subject.\n   * \n   * @param  {any} subject\n   * @return {anim8.Animator}\n   */\n  animatorFor: function(subject)\n  {\n    var animator = subject.$animator;\n      \n    if ( !animator )\n    {\n      animator = new anim8.Animator( subject );\n      animator.factory = this;\n      animator.frame = subject;\n      \n      subject.$animator = animator;\n    }\n    \n    return animator;\n  },\n\n  /**\n   * Destroys the animator by unlinking the animator from the subject.\n   * \n   * @param  {anim8.Animator} animator\n   * @return {void}\n   */\n  destroy: function(animator)\n  {\n    delete animator.subject.$animator;\n  },\n\n  /**\n   * Returns the attribute descriptor for the given attribute.\n   * \n   * @param  {string} attr\n   * @return {object}\n   */\n  attribute: function(attr)\n  {\n    var attribute = this.attributes[ attr ];\n\n    if ( !attribute )\n    {\n      attribute = this.attributes[ attr ] = anim8.object.attribute( attr );\n\n      var calculatorName = attribute.calculator;\n      var calculator = anim8.calculator( calculatorName );\n      var defaultValue = calculator.parse( attribute.defaultValue, calculator.ZERO );\n\n      attribute.calculatorName = calculatorName;\n      attribute.calculator = calculator;\n      attribute.defaultValue = defaultValue;\n      attribute.name = attr;\n      attribute.parse = function(value) {\n        return this.calculator.parse( value, this.defaultValue );\n      };\n      attribute.cloneDefault = function() {\n        return this.calculator.clone( this.defaultValue );\n      };\n    }\n\n    return attribute;\n  }\n\n});\n\n/**\n * Registers the object factory.\n */\nanim8.factory['default'] = anim8.factory['object'] = new anim8.ObjectFactory();\n\n/**\n * The Object namespace.\n * \n * @type {Object}\n */\nanim8.object = {};\n\n/**\n * Returns an attribute based on the given input. If the input is an object it's assumed to be an attribute and it's\n * returned immediately. If the input is a string the attribute with the given name is returned. Otherwise\n * the default attribute is returned.\n *\n * @param {object|string} attr\n */\nanim8.object.attribute = function(attr) \n{\n  if ( anim8.isObject( attr ) && anim8.isDefined( attr.defaultValue ) ) \n  {\n    return attr;\n  }\n  if ( anim8.isString( attr ) && attr in anim8.object.attribute ) \n  {\n    return anim8.object.attribute[ attr ];\n  }\n  \n  return anim8.object.attribute.default;\n};\n\n/**\n * The default attribute.\n */\nanim8.object.attribute['default']                 = {defaultValue: 0};\n"],"sourceRoot":"/source/"}