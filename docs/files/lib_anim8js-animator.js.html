<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/anim8js-animator.js - anim8js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="anim8js" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/anim8.html">anim8</a></li>
                                <li><a href="../classes/anim8.Animation.html">anim8.Animation</a></li>
                                <li><a href="../classes/anim8.Animator.html">anim8.Animator</a></li>
                                <li><a href="../classes/anim8.Animators.html">anim8.Animators</a></li>
                                <li><a href="../classes/anim8.Attrimator.html">anim8.Attrimator</a></li>
                                <li><a href="../classes/anim8.AttrimatorMap.html">anim8.AttrimatorMap</a></li>
                                <li><a href="../classes/anim8.defaults.html">anim8.defaults</a></li>
                                <li><a href="../classes/anim8.DeferAnimator.html">anim8.DeferAnimator</a></li>
                                <li><a href="../classes/anim8.delegate.html">anim8.delegate</a></li>
                                <li><a href="../classes/anim8.eventize.html">anim8.eventize</a></li>
                                <li><a href="../classes/anim8.Path.html">anim8.Path</a></li>
                                <li><a href="../classes/anim8.Tween.html">anim8.Tween</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/anim8.html">anim8</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: lib/anim8js-animator.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

/**
 * Instantiates a new Animator given a subject to animate.
 *
 * @param {any} e
 * @class Animator
 * @constructor
 * @namespace anim8
 */
anim8.Animator = function(e) 
{
  this.reset( e );
};

/**
 * The event triggered after preupdate is called. Pre-update is used to run any
 * preparations on the subject before updates are made and attributes are 
 * applied.
 * 
 * @event preupdate
 */

/**
 * The event triggered after all attrimators are updated and any new values
 * have been applied to the current values (frame) on the animator.
 * 
 * @event update
 */

/**
 * The event triggered after the current values (frame) on the animator are
 * applied to the subject.
 * 
 * @event apply
 */

/**
 * The event triggered when the given animation cycle starts (and initial 
 * values are applied) for all attrimators in the cycle.
 * 
 * @event cycleStart:#
 * @param {Number} cycleID
 */

/**
 * The event triggered when the given animation cycle ends which occurs when the
 * last attrimator for an animation finishes or is interrupted by commands like 
 * play, queue, transition, end, finish, &amp; stop.
 * 
 * @event cycleEnd:#
 * @param {Number} cycleID
 */

/**
 * The event triggered when all animations on the animator have finished.
 * 
 * @event finished
 * @param {anim8.Animator} animator
 */

/**
 * The event triggered when an animator is deactivated which occurs when an 
 * animator has finished animating and is being taken off the list of live
 * animators (anim8.animating).
 * 
 * @event deactivate
 */

/**
 * The event triggered after the user calls destroy on an animator.
 * 
 * @event destroyed
 */

anim8.fn = anim8.Animator.prototype = 
{

  /**
   * Resets the animator given a subject to animate.
   *
   * @method reset
   * @param {any} subject
   * @chainable
   * @protected
   */
  reset: function(subject)
  {
    /**
     * The subject which is being animated.
     *
     * @property subject
     * @type Any
     */
    this.subject = subject;

    /**
     * The map of attrimators animating the subject.
     *
     * @property attrimators
     * @type anim8.AttrimatorMap
     */
    this.attrimators = new anim8.AttrimatorMap();

    /**
     * The array of attrimators recently added to the animator that
     * are ready to be started.
     *
     * @property attrimatorsAdded
     * @protected
     */
    this.attrimatorsAdded = [];

    /**
     * The object which stores the attribute values being animated.
     *
     * @property frame
     * @type {Object}
     */
    this.frame = {};

    /**
     * The object which stores the attributes last updated.
     *
     * @property updated
     * @type {Object}
     */
    this.updated = {};

    /**
     * Whether or not this animator has completely finished animating it&#x27;s subject.
     *
     * @property finished
     * @type {Boolean}
     */
    this.finished = false;

    /**
     * The factory which created this Animator given a subject.
     *
     * @property factory
     * @type {anim8.Factory}
     */
    this.factory = null;

    /**
     * Whether or not this animator is actively being updated.
     *
     * @property active
     * @type {Boolean}
     */
    this.active = false;

    /**
     * The current cycle being animated. Multiple cycles can be animated at once, this is the first one.
     *
     * @property cycleCurrent
     * @type {Number}
     * @protected
     */
    this.cycleCurrent = 0;

    /**
     * The ID of the next cycle of animations to be added to this Animator.
     *
     * @property cycleNext
     * @type {Number}
     * @protected
     */
    this.cycleNext = 0;

    /**
     * The last cycle that was ended.
     *
     * @property cycleEnded
     * @type {Number}
     * @protected
     */
    this.cycleEnded = 0;
    
    return this;
  },

  /**
   * Starts a new animation cycle. This is done before events &amp; springs are 
   * placed to group them together so we know when to apply their initial value.
   *
   * @method newCycle
   * @param {anim8.Attrimator|anim8.AttrimatorMap} attrimators
   * @chainable
   * @protected
   */
  newCycle: function(attrimators)
  {
    this.cycleNext++;

    if ( attrimators instanceof anim8.AttrimatorMap )
    {
      this.cycleNext = attrimators.applyCycle( this.cycleNext );
    }
    else if ( attrimators instanceof anim8.Attrimator )
    {
      attrimators.cycle = this.cycleNext;
    }

    return this;
  },

  /**
   * Applies the current cycle. This involves finding all attrimators with the 
   * same cycle identifier and applying their initial state.
   * 
   * @method applyCurrentCycle
   * @chainable
   * @protected
   */
  applyCurrentCycle: function()
  {
    var cycle = this.cycleCurrent;
    var attrimators = this.attrimators.values;

    for (var i = attrimators.length - 1; i &gt;= 0; i--)
    {
      var attrimator = attrimators[ i ];
      var attr = attrimator.attribute;

      if ( attrimator.cycle === cycle )
      {
        this.updated[ attr ] = (attrimator.startCycle( this.frame ) !== false) || this.updated[ attr ];
      }
    }

    return this;
  },

  /**
   * Ends the current cycle which calls any listening functions.
   * 
   * @method endCurrentCycle
   * @chainable
   * @protected
   */
  endCurrentCycle: function()
  {
    if ( this.cycleCurrent &gt; this.cycleEnded )
    {
      this.cycleEnded = this.cycleCurrent;
      this.trigger( &#x27;cycleEnd:&#x27; + this.cycleCurrent, this.cycleCurrent ); 
    }
  },

  /**
   * Returns the attribute descriptor given the name of the attribute.
   * 
   * @method getAttribute
   * @param  {String} attr
   * @return {Object}
   */
  getAttribute: function(attr)
  {
    return this.factory.attribute( attr );
  },
  
  /**
   * Restores any temporary state that may exist on this Animator that
   * is a result from animations.
   *
   * @method restore
   * @chainable
   */
  restore: function()
  { 
    return this;
  },

  /**
   * Applies the initial state of recently added attrimators immediately.
   * 
   * @method applyInitialState
   * @chainable
   */
  applyInitialState: function()
  {
    var now = anim8.now();

    this.preupdate( now );
    this.update( now );
    this.apply();

    return this;
  },
  
  /**
   * A method thats invoked along with all other animators before updates are 
   * called. This is used to make any necessary preparations before the animator
   * is updated.
   *
   * @method preupdate
   * @param {Number} now
   * @chainable
   */
  preupdate: function(now)
  {
    // If there are attribute placed on the animator since the last preupdate
    // that has computed values we need to replace the path on the event with
    // a copy containing the computed values. This is where current value &amp; 
    // relative values are injected from the animator into the attribute.
    var aa = this.attrimatorsAdded;
    if ( aa.length )
    {
      for (var i = 0; i &lt; aa.length; i++)
      {
        var attrimator = aa[ i ];
        var attr = attrimator.attribute;

        if ( attr in this.subject )
        {
          this.frame[ attr ] = this.subject[ attr ];
        }
        else
        {
          this.setDefault( attr );          
        }

        attrimator.start( now, this );     
      }

      aa.length = 0;
    }

    this.trigger(&#x27;preupdate&#x27;);
    
    return this;
  },

  /**
   * Sets the default value for the given attribute in the frame of this 
   * Animator if there&#x27;s no value there.
   * 
   * @method setDefault
   * @param {String} attr
   * @protected
   */
  setDefault: function(attr)
  {
    if ( !(attr in this.frame) )
    {
      this.frame[ attr ] = this.getAttribute( attr ).cloneDefault();
    }
  },
  
  /**
   * Updates all attrimators in this animator with the given time.
   *
   * @method update
   * @param {Number} now
   * @chainable
   */
  update: function(now) 
  {  
    this.wasFinished = this.finished;
    this.finished = true;

    var attrimators = this.attrimators.values;
    var minCycle = this.cycleNext;

    for (var i = attrimators.length - 1; i &gt;= 0; i--)
    {
      var attrimator = attrimators[ i ];
      var attr = attrimator.attribute;

      this.updated[ attr ] = attrimator.setTime( now, this.frame );

      this.finished = this.finished &amp;&amp; attrimator.isFinished();

      minCycle = Math.min( minCycle, attrimator.cycle );
    }

    if ( this.cycleCurrent &lt; minCycle )
    {
      while ( this.cycleCurrent &lt; minCycle )
      {
        this.endCurrentCycle();
        this.cycleCurrent++;
      }

      this.cycleCurrent = minCycle;
      this.applyCurrentCycle();
      this.trigger( &#x27;cycleStart:&#x27; + this.cycleCurrent, this.cycleCurrent );
    }

    if ( !this.wasFinished &amp;&amp; this.finished )
    {
      this.endCurrentCycle();
    }

    this.trigger(&#x27;update&#x27;);
    
    return this;
  },

  /**
   * Places the attribute animator in this animator replacing any existing 
   * animator for the same attribute. The next time the animator is updated the 
   * attribute animator will be started. The previous (if any) attrimator is
   * returned.
   * 
   * @method placeAttrimator
   * @param {anim8.Attrimator} attrimator
   * @return {anim8.Attrimator}
   */
  placeAttrimator: function(attrimator)
  {
    var attr = attrimator.attribute;
    var existing = this.attrimators.get( attr );

    this.attrimators.put( attr, attrimator );
    this.attrimatorsAdded.push( attrimator );

    this.finished = false;

    return existing;
  },
  
  /**
   * Applies all updated attributes to the subject. This method is invoked with 
   * all of the other animators at the end of the animation cycle.
   *
   * @method apply
   * @chainable
   */
  apply: function()
  {
    for (var attr in this.frame)
    {
      if ( this.updated[ attr ] )
      {
        this.subject[ attr ] = this.frame[ attr ]; 
        this.updated[ attr ] = false;
      }
    }
  
    this.trigger(&#x27;apply&#x27;);
  
    this.trimAttrimators();
    
    return this;
  },
  
  /**
   * Removes any finished attrimators and places any queued attrimators. If the
   * animator previously wasn&#x27;t finished but now is the &#x27;finished&#x27; event will
   * be triggered.
   *
   * @method trimAttrimators
   * @chainable
   * @protected
   */
  trimAttrimators: function()
  {
    var attrimators = this.attrimators.values;

    for (var i = attrimators.length - 1; i &gt;= 0; i--)
    {
      var attrimator = attrimators[ i ];

      if ( attrimator.isFinished() )
      {
        if ( attrimator.next )
        {
          this.placeAttrimator( attrimator.next );
        }
        else
        {
          this.attrimators.removeAt( i );
        }
      }
    }
    
    if ( !this.wasFinished &amp;&amp; this.finished )
    {
      this.trigger( &#x27;finished&#x27;, this );
    }

    return this;
  },
  
  /**
   * Returns the current value for the given attribute (or undefined if the 
   * attribute is not or has not animated).
   *
   * @method value
   * @param {String} attr
   * @return {any}
   */
  value: function(attr)
  {
    return this.frame[ attr ];
  },

  /**
   * Activates this Animator by adding it to the main loop if it isn&#x27;t there 
   * already.
   * 
   * @method activate
   * @chainable
   */
  activate: function()
  {
    anim8.add( this );

    return this;
  },
  
  /**
   * A method that is invoked when an animator is finished and is being removed 
   * from the list of currently animating Animators.
   *
   * @method deactivate
   * @chainable
   */
  deactivate: function()
  { 
    this.trigger(&#x27;deactivate&#x27;, this);

    return this;
  },
  
  /**
   * A method that can be invoked to destroy an animator - removing any 
   * relationship between the subject and animator. The next time an animator is
   * generated for the subject a new animator will be created.
   *
   * @method destroy
   * @chainable
   */
  destroy: function()
  {
    this.finished = true;

    this.factory.destroy( this );
    
    this.trigger(&#x27;destroyed&#x27;);

    return this;
  },
  
  /**
   * Creates a map of attrimators based on the animation and options given. For
   * each anim8.Animation instance thats being converted into attrimators,
   * the onAnimation(animation, option, attrimatorMap) function is invoked.
   *
   * @method createAttrimators
   * @param {anim8.Animation|String|Object} animation
   * @param {String|Object} [options]
   * @param {Boolean} [cache=false]
   * @return {anim8.AttrimatorMap}
   * @protected
   * See: {{#crossLink &quot;anim8/animation:method&quot;}}{{/crossLink}}
   */
  createAttrimators: function(animation, options, cache)
  {
    var options = anim8.options( options );    
    var animation = anim8.animation( animation, options, cache );
  
    if (animation === false)
    {
      return false;
    }
    
    var attrimators = animation.newAttrimators();
    
    if ( animation.isSaved() &amp;&amp; !anim8.isEmpty( options ) )
    { 
      animation.merge( options, attrimators );
    }
    
    this.onAnimation( animation, options, attrimators );

    while ( animation.next !== null )
    {
      animation = animation.next;

      var queueAttrimators = animation.newAttrimators();

      this.onAnimation( animation, options, queueAttrimators );

      attrimators.queueMap( queueAttrimators );
    }

    return attrimators;
  },
  
  /**
   * A method invoked when an animation is about to be played in the Animator.
   * 
   * @method onAnimation
   * @param {anim8.Animation} animation
   * @param {Object} options
   * @param {anim8.AttrimatorMap} attrimatorMap
   * @protected
   */
  onAnimation: function(animation, options, attrimatorMap)
  {
    
  },
  
  /**
   * Adds a spring to this animator replacing any existing attrimator for the 
   * same attribute. A spring object can be given, an instance of anim8.Spring, 
   * or a name of a saved Spring. The spring added to the animator is returned.
   * 
   * @method spring
   * @param {anim8.Spring|String|Object} spring
   * @return {anim8.Spring}
   */
  spring: function(spring)
  {
    var spring = anim8.spring( spring );
    
    if ( spring === false )
    {
      return false;
    }

    this.newCycle( spring );
    this.placeAttrimator( spring );
    
    this.activate();
    
    return spring;
  },
  
  /**
   * Plays an animation. Attributes in the animation that are currently being
   * animated will be stopped and replaced with the new attrimators. If &#x60;all&#x60; is
   * true then any attrimators animating not specified in the given animation
   * will be stopped.
   *
   * **See:** {{#crossLink &quot;anim8/animation:method&quot;}}{{/crossLink}},
   *          {{#crossLink &quot;anim8/options:method&quot;}}{{/crossLink}}
   *
   * @method play
   * @param {anim8.Animation|String|Object} animation
   * @param {String|Object} [options]
   * @param {Boolean} [all=false] 
   * @param {Boolean} [cache=false]
   * @chainable
   */
  play: function(animation, options, all, cache)
  {
    var attrimatorMap = this.createAttrimators( animation, options, cache );
    
    if ( attrimatorMap === false )
    {
      return false;
    }
    
    this.newCycle( attrimatorMap );
    this.playAttrimators( attrimatorMap, all );

    return this.activate();
  },

  /**
   * Plays a map of attrimators. Attributes in the attrimator map that are 
   * currently being animated will be stopped and replaced with the new
   * attrimators. If &quot;all&quot; is true then any attrimators animating not specified
   * in the given attrimator map will be stopped. This method will not activate 
   * the Animator, that has to be done manually.
   * 
   * @method playAttrimators
   * @param  {anim8.AttrimatorMap} animatorMap
   * @param  {Boolean} [all]
   * @chainable
   * @protected
   */
  playAttrimators: function(attrimatorMap, all)
  {
    if ( all )
    {
      this.finishNotPresent( attrimatorMap, 0 );
    }

    var attrimators = attrimatorMap.values;

    for (var i = attrimators.length - 1; i &gt;= 0; i--)
    {
      this.placeAttrimator( attrimators[i] );
    }
    
    return this;
  },
  
  /**
   * Queues an animation. The attrimators generated from the given animation 
   * will be started at the same time - as soon as all finite attrimators for
   * the same attributes are finished. Any infinite attrimators will be 
   * automatically stopped when all queued attrimators are set to start.
   *
   * @method queue
   * @param {anim8.Animation|String|Object} animation
   * @param {String|Object} [options]
   * @param {Boolean} [cache]
   * @chainable
   * @uses anim8.animation
   * @uses anim8.options
   */
  queue: function(animation, options, cache)
  {
    var attrimatorMap = this.createAttrimators( animation, options, cache );
    
    if ( attrimatorMap === false )
    {
      return false;
    }
        
    this.newCycle( attrimatorMap );
    this.queueAttrimators( attrimatorMap );

    return this.activate();
  },

  /**
   * Queues a map of attrimators. The map of attrimators will be started at the
   * same time - as soon as all finished attrimators for the same attribute are
   * finished. Any infinite attrimators will be automatically stopped when all
   * queued attrimators are set to start.
   * 
   * @method queueAttrimators
   * @param {anim8.AttrimatorMap} attrimatorMap
   * @chainable
   * @protected
   */
  queueAttrimators: function(attrimatorMap)
  {
    this.attrimators.queueMap( attrimatorMap, this.placeAttrimator, this );
    
    return this;
  },
  
  /**
   * Transitions from the currently playing attrimators into the beginning of a 
   * new animation. Several parameters can be specified in the transition object
   * which determine how the transition is made. If &quot;all&quot; is true then any 
   * attrimators animating not specified in the given animation will be stopped.
   *
   * time: the total time to take to transition into a new animation.
   * outro: time to look into the future for the current attrimator to curve to.
   * intro: time to look into the future for the next attrimator to curve into.
   * lookup: time to look into the future to calculate velocity which is used
   *   for negative intros and maintaing consistent exit &amp; entrance velocity.
   * granularity: when greater than 2 it activates smooth transitions where the
   *    velocity of the new &amp; old attrimators is maintained over the transition.
   * 
   * @method transition
   * @param {String|Array|Object} transition
   * @param {String|Object|anim8.Animation} animation
   * @param {Object} [options]
   * @param {Boolean} [all]
   * @param {Boolean} [cache]
   * @chainable
   * @uses anim8.transition
   * @uses anim8.animation
   * @uses anim8.options
   * @uses anim8.Animator.transitionAttrimators
   */
  transition: function(transition, animation, options, all, cache)
  {
    var transition = anim8.transition( transition );
    var attrimatorMap = this.createAttrimators( animation, options, cache );
    
    if ( attrimatorMap === false )
    {
      return false;
    }

    this.newCycle( attrimatorMap );
    this.transitionAttrimators( transition, attrimatorMap, all );

    return this.activate();
  },

  /**
   * Transitions from the currently playing attrimators into the beginning of a
   * new animation. Several parameters can be specified in the transition object
   * which determine how the transition is made. If &quot;all&quot; is true then any 
   * attrimators animating not specified in the given attrimator map will be 
   * stopped.
   *
   * time: the total time to take to transition into a new animation.
   * outro: time to look into the future for the current attrimator to curve to.
   * intro: time to look into the future for the next attrimator to curve into.
   * lookup: time to look into the future to calculate velocity which is used
   *   for negative intros and maintaing consistent exit &amp; entrance velocity.
   * granularity: when greater than 2 it activates smooth transitions where the
   *    velocity of the new &amp; old attrimators is maintained over the transition.
   *
   * @method transitionAttrimators
   * @param {Object} transition
   * @param {anim8.AttrimatorMap} attrimatorMap
   * @param {Boolean} [all]
   * @chainable
   * @protected
   */
  transitionAttrimators: function(transition, attrimatorMap, all)
  {
    // TRANSITIONING:
    // If the animator doesn&#x27;t have an attrimator for the given attribute just add the attrimator adding the total delay
    // If the animator has an attrimator currently...
    //   If the current attrimator or new attrimator don&#x27;t have values at the desired times...
    //      Stop the current attrimator after the total delay (adding the delay of the new attrimator as well)
    //      Queue the new attrimator
    //   Else
    //      Create a path using the methods detailed above
    // If all is true and there&#x27;s an attrimator left on the animator that isn&#x27;t being transitioned, stop it after the total delay.

    // CREATING A TRANSITION PATH:
    // If intro &amp; outro are 0, use Tween
    // If intro is 0, use Quadratic Path between current value, outro point, and first point on new path.
    // If outro is 0, use Quadratic Path between current value, first point on new path, and intro point.
    // If intro &amp; outro are not 0, use Cubic Path between current value, outro point, first point on new path, and intro point.
    // If granularity is given &gt; 1 then compile the path, compute intro &amp; outro velocities, and compute deltas for new 
    //    compiled path based on interpolated velocity over the path (knowing it&#x27;s length and transition time)

    var current = this.attrimators;
    var attrimators = attrimatorMap.values;

    // If transition all attributes, 
    if ( all )
    {
      this.finishNotPresent( attrimatorMap, transition.time );
    }

    // Only transition if we need to
    if ( current.hasOverlap( attrimatorMap ) )
    {
      for (var i = attrimators.length - 1; i &gt;= 0; i--)
      {
        var next = attrimators[ i ];
        var attr = next.attribute;
        var curr = current.get( attr );

        if ( curr &amp;&amp; anim8.isDefined( this.frame[ attr ] ) )
        {
          var attribute = this.getAttribute( attr );
          var calc = attribute.calculator;

          var p2 = next.valueAt( 0, calc.create() );
          
          if ( p2 !== false )
          {
            var transitionTime = transition.time;
            var p0 = calc.clone( this.frame[ attr ] );            
            var p1 = transition.outro ? curr.valueAt( curr.getElapsed() + transition.outro, calc.create() ) : false;
            var p3 = transition.intro ? next.valueAt( transition.intro, calc.create() ) : false;
            var path = null;

            // If the intro is negative we can look into the past by looking a little bit into
            // the future and assume the past is going in the same direction (only the opposite). 
            if ( p3 !== false &amp;&amp; transition.intro &lt; 0 &amp;&amp; transition.lookup &gt; 0 )
            {
              var pastLookahead = next.valueAt( transition.lookup, calc.create() );
              var pastVelocity = calc.sub( pastLookahead, p2 );

              if ( pastVelocity !== false )
              {
                var pastNegativeVelocity = calc.scale( pastVelocity, transition.intro / transition.lookup );
                var past = calc.add( pastNegativeVelocity, p2 );
                
                p3 = p2;
                p2 = past;
              }
            }

            // Build a path with as many of the points as possible.
            if ( p1 === false &amp;&amp; p3 === false )
            {
              path = new anim8.Tween( attr, calc, p0, p2 );
            }
            else if ( p1 === false )
            {
              path = new anim8.PathQuadratic( attr, calc, p0, p2, p3 );
            }
            else if ( p3 === false )
            {
              path = new anim8.PathQuadratic( attr, calc, p0, p1, p2 );
            }
            else
            {
              path = new anim8.PathCubic( attr, calc, p0, p1, p2, p3 );
            }
            
            // If granularity is specified we will try to make the transition 
            // smooth by maintaining exit (outro) velocity from the current attrimator
            // and interpolating it to the entrance (intro) velocity for the 
            // attrimator we&#x27;re transitioning into.
            if ( transition.granularity &gt; 2 &amp;&amp; transition.lookup &gt; 0 )
            { 
              var outTime  = p1 === false ? curr.getElapsed() : curr.getElapsed() + transition.outro;
              var outPoint = p1 === false ? p0 : p1;
              var outNext  = curr.valueAt( outTime + transition.lookup, calc.create() );

              var inTime   = p3 === false ? 0 : transition.intro;
              var inPoint  = p3 === false ? p2 : p3;
              var inNext   = next.valueAt( inTime + transition.lookup, calc.create() );

              // We can only proceed if we have reference points to calculate
              // exit &amp; entrance velocity.
              if ( outNext !== false &amp;&amp; inNext !== false )
              {
                var outVelocity  = calc.sub( calc.clone( outNext ), outPoint );
                var outPerMillis = calc.length( outVelocity ) / transition.lookup;

                var inVelocity   = calc.sub( calc.clone( inNext ), inPoint );
                var inPerMillis  = calc.length( inVelocity ) / transition.lookup;

                var compiled = new anim8.PathCompiled( attr, path, transition.granularity );
                var points = compiled.points;
                var lastPoint = points.length - 1;
                var totalDistance = 0;
                var distances = [];

                for (var k = 0; k &lt; lastPoint; k++)
                {
                  distances[ k ] = totalDistance;
                  totalDistance += calc.distance( points[ k ], points[ k + 1 ] );
                }
                distances[ lastPoint ] = totalDistance;

                if ( !isNaN( totalDistance ) )
                {
                  var requiredTime = 2.0 * totalDistance / (outPerMillis + inPerMillis);
                  var acceleration = 0.5 * (inPerMillis - outPerMillis) / requiredTime;
                  var timeDelta = requiredTime / lastPoint;
                  var deltas = [];

                  for (var k = 0; k &lt; lastPoint; k++)
                  { 
                    var time = k * timeDelta;
                    var position = outPerMillis * time + acceleration * time * time;

                    deltas[ k ] = position / totalDistance;
                  }
                  deltas[ lastPoint ] = 1.0;

                  path = new anim8.PathDelta( attr, calc, points, deltas );
                  transitionTime = requiredTime;
                }
              }
            }

            var transitionEvent = new anim8.Event( attr, path, transitionTime, transition.easing, 0, 0, 1 );
          
            transitionEvent.next = next;
            transitionEvent.cycle = next.cycle;

            next.offset = transition.intro;

            this.placeAttrimator( transitionEvent );
          }
          else
          {
            curr.stopIn( transition.time + next.delay );
            curr.queue( next );
            next.delay = 0;
          }
        }
        else
        {
          next.delay += transition.time;
          
          this.placeAttrimator( next );
        }
      }
    }
    // We don&#x27;t need to transition, just play the events
    else
    {
      for (var i = attrimators.length - 1; i &gt;= 0; i--)
      {
        this.placeAttrimator( attrimators[ i ] );
      }
    }
    
    return this;
  },

  /**
   * Finishes any attrimators on this animator that are not present in the given
   * map of attrimators. Optionally a delay in stopping them can be given.
   * 
   * @method finishNotPresent
   * @param {anim8.AttrimatorMap} attrimatorMap
   * @param {Number} [delay=0]
   * @chainable
   * @protected
   */
  finishNotPresent: function(attrimatorMap, delay)
  {
    var attrimators = this.attrimators.values;
    var stopIn = delay || 0;

    for (var i = attrimators.length - 1; i &gt;= 0; i--)
    {
      var attrimator = attrimators[ i ];

      if ( !attrimatorMap.has( attrimator.attribute ) )
      {
        attrimator.stopIn( stopIn );
      }
    }

    return this;
  },

  /**
   * Tweens a single attribute to a target value.
   *
   * @method tweenTo
   * @param {String} attr
   * @param {T} target
   * @param {String|Array|Object} [options]
   * @chainable
   * @uses anim8.options
   */
  tweenTo: function(attr, target, options)
  {
    var options   = anim8.options( options );
    var attribute = this.getAttribute( attr );
    var end       = attribute.parse( target );
    var path      = new anim8.Tween( attr, attribute.calculator, anim8.computed.current, end );
    var event     = new anim8.Event( attr, path, options.duration, options.easing, options.delay, options.sleep, options.repeat, options.scale, options.scaleBase );
    
    this.newCycle( event );
    this.placeAttrimator( event );
    
    return this.activate();
  },

  /**
   * Tweens multiple attributes to target values.
   *
   * @method tweenManyTo
   * @param {Object} targets
   * @param {String|Array|Object} [options]
   * @chainable
   * @uses anim8.options
   */
  tweenManyTo: function(targets, options)
  {
    var options = anim8.options( options );

    this.newCycle();

    for ( var attr in targets )
    {
      var attribute = this.getAttribute( attr );
      var end       = attribute.parse( targets[ attr ] );
      var path      = new anim8.Tween( attr, attribute.calculator, anim8.computed.current, end );
      var event     = new anim8.Event( attr, path, options.duration, options.easing, options.delay, options.sleep, options.repeat, options.scale, options.scaleBase );
      
      event.cycle = this.cycleNext;
      this.placeAttrimator( event );
    }

    return this.activate();
  },

  /**
   * Tweens a single attribute from a starting value to the current value.
   *
   * @method tweenFrom
   * @param {String} attr
   * @param {T} starting
   * @param {String|Array|Object} [options]
   * @chainable
   * @uses anim8.options
   */
  tweenFrom: function(attr, starting, options)
  {
    var options   = anim8.options( options );
    var attribute = this.getAttribute( attr );
    var start     = attribute.parse( starting );
    var path      = new anim8.Tween( attr, attribute.calculator, start, anim8.computed.current );
    var event     = new anim8.Event( attr, path, options.duration, options.easing, options.delay, options.sleep, options.repeat, options.scale, options.scaleBase );
    
    this.newCycle( event );
    this.placeAttrimator( event );
    
    return this.activate();
  },

  /**
   * Tweens multiple attributes from starting values to the current values.
   *
   * @method tweenManyFrom
   * @param {Object} startings
   * @param {String|Array|Object} [options]
   * @chainable
   * @uses anim8.options
   */
  tweenManyFrom: function(startings, options)
  {
    var options = anim8.options( options );

    this.newCycle();

    for ( var attr in startings )
    {
      var attribute = this.getAttribute( attr );
      var start     = attribute.parse( startings[ attr ] );
      var path      = new anim8.Tween( attr, attribute.calculator, start, anim8.computed.current );
      var event     = new anim8.Event( attr, path, options.duration, options.easing, options.delay, options.sleep, options.repeat, options.scale, options.scaleBase );
      
      event.cycle = this.cycleNext;
      this.placeAttrimator( event );
    }

    return this.activate();
  },
  
  /**
   * Tweens an attribute from a starting value to an ending value.
   *
   * @method tween
   * @param {String} attr
   * @param {T} starts
   * @param {T} ends
   * @param {String|Array|Object} [options]
   * @chainable
   * @uses anim8.options
   */
  tween: function(attr, starts, ends, options)
  {
    var options   = anim8.options( options );
    var attribute = this.getAttribute( attr );
    var start     = attribute.parse( starts );
    var end       = attribute.parse( ends );
    var path      = new anim8.Tween( attr, attribute.calculator, start, end );
    var event     = new anim8.Event( attr, path, options.duration, options.easing, options.delay, options.sleep, options.repeat, options.scale, options.scaleBase );
    
    this.newCycle( event );
    this.placeAttrimator( event );

    return this.activate();
  },
  
  /**
   * Tweens multiple attributes from starting values to ending values.
   *
   * @method tweenMany
   * @param {Object} starts
   * @param {Object} ends
   * @param {String|Array|Object} [options]
   * @chainable
   * @uses anim8.options
   */
  tweenMany: function(starts, ends, options)
  {
    var options = anim8.options( options );

    this.newCycle();

    for ( var attr in starts )
    {
      var attribute = this.getAttribute( attr );
      var start     = attribute.parse( starts[ attr ] );
      var end       = attribute.parse( ends[ attr ] );
      var path      = new anim8.Tween( attr, attribute.calculator, start, end );
      var event     = new anim8.Event( attr, path, options.duration, options.easing, options.delay, options.sleep, options.repeat, options.scale, options.scaleBase );
      
      event.cycle = this.cycleNext;
      this.placeAttrimator( event );
    }

    return this.activate();
  },

  /**
   * Moves an attribute relative to its current value.
   * 
   * @method move
   * @param {String} attr
   * @param {T} amount
   * @param {String|Array|Object} [options]
   * @chainable
   */
  move: function(attr, amount, options)
  {
    var options   = anim8.options( options );
    var attribute = this.getAttribute( attr );
    var relative  = attribute.parse( amount );
    var start     = anim8.computed.current;
    var end       = anim8.isComputed( relative ) ? relative : anim8.computed.relative( relative );
    var path      = new anim8.Tween( attr, attribute.calculator, start, end );
    var event     = new anim8.Event( attr, path, options.duration, options.easing, options.delay, options.sleep, options.repeat, options.scale, options.scaleBase );
    
    this.newCycle( event );
    this.placeAttrimator( event );

    return this.activate();
  },

  /**
   * Moves multiple attribute relative to their current value.
   * 
   * @method moveMany
   * @param {Object} amounts
   * @param {String|Array|Object} [options]
   * @chainable
   */
  moveMany: function(amounts, options)
  {
    var options = anim8.options( options );

    this.newCycle();

    for ( var attr in amounts )
    {
      var attribute = this.getAttribute( attr );
      var relative  = attribute.parse( amounts[ attr ] );
      var start     = anim8.computed.current;
      var end       = anim8.isComputed( relative ) ? relative : anim8.computed.relative( relative );
      var path      = new anim8.Tween( attr, attribute.calculator, start, end );
      var event     = new anim8.Event( attr, path, options.duration, options.easing, options.delay, options.sleep, options.repeat, options.scale, options.scaleBase );
      
      event.cycle = this.cycleNext;
      this.placeAttrimator( event );
    }

    return this.activate();
  },
  
  /**
   * Returns a function that returns the current value for the given attribute 
   * when invoked. The returned function can be given as values for paths &amp; 
   * springs that are evaluated every frame.
   * 
   * @method ref
   * @param {String} attr
   * @return {Function}
   */
  ref: function(attr)
  {
    var animator = this;
    var attribute = this.getAttribute( attr );
    var request = {};
    
    return function()
    {
      if ( attr in animator.frame )
      {
        return animator.frame[ attr ];
      }
      
      request[ attr ] = true;
      
      var current = animator.get( request );
      
      if ( anim8.isDefined( current[ attr ] ) )
      {
        return current[ attr ];
      }
      
      return attribute.defaultValue;
    };
  },
  
  /**
   * Follows the attribute along the given path definition.
   * 
   * @method follow
   * @param {String} attribute
   * @param {anim8.Path|Object|String} path
   * @param {Object} [options]
   * @chainable
   * @uses anim8.options
   */
  follow: function(attribute, path, options)
  {
    var options = anim8.options( options );
    var path = anim8.path( path );
    
    var event = new anim8.Event( 
      attribute, 
      path, 
      options.duration,
      options.easing,
      options.delay, 
      options.sleep,
      options.repeat,
      options.scale,
      options.scaleBase
    );
    
    this.newCycle( event );
    this.placeAttrimator( event );
    
    return this.activate();
  },
  
  /**
   * Helper method that iterates over given attributes. If callback is specified
   * it is invoked for each attrimator in this animator for the given 
   * attributes. If no callback is given an array of anim8.Attrimators is 
   * returned for each attrimator in this animator for the given attributes.
   *
   * @method attrimatorsFor
   * @param {String|Array} attributes
   * @param {Function} callback
   * @return {this|Array}
   */
  attrimatorsFor: function(attributes, callback)
  {
    if ( anim8.isString( attributes ) )
    {
      attributes = attributes.split( &#x27; &#x27; );
    }
   
    var attrimatorMap = this.attrimators; 
    var resulting = !anim8.isFunction( callback );
    var results = [];
    
    if ( anim8.isArray( attributes ) )
    {
      for (var i = 0; i &lt; attributes.length; i++)
      {
        var attr = attributes[i];
        var attrimator = attrimatorMap.get( attr );
        
        if ( attrimator )
        {
          if ( resulting )
          {
            results.push( attrimator );
          }
          else
          {
            callback.call( this, attrimator, attr );
          }
        }
      }
    }
    else
    {
      var attrimators = attrimatorMap.values;

      for (var i = attrimators.length - 1; i &gt;= 0; i--)
      {
        var attrimator = attrimators[ i ];

        if ( resulting )
        {
          results.push( attrimator );
        }
        else
        {
          callback.call( this, attrimator, attrimator.attribute );
        }
      }
    }
    
    return resulting ? results : this;
  },
  
  /**
   * Stops all attributes for the specified attributes. Attribute names can be 
   * given as an array or a space separated string. If no attributes are given 
   * all attributes are assumed.
   *
   * @method stop
   * @param {String|Array} [attributes]
   * @chainable
   */
  stop: function(attributes)
  {
    return this.attrimatorsFor( attributes, function(attrimator, attr) 
    {
      this.attrimators.remove( attr );
    });
  },
  
  /**
   * Ends all attributes for the specified attributes. If attributes are queued 
   * the last value of the last attribute is applied to this Animator before 
   * being completely removed. Attribute names can be given as an array or a 
   * space separated string. If no attributes are given all attributes are 
   * assumed.
   *
   * @method end
   * @param {String|Array} [attributes]
   * @chainable
   */
  end: function(attributes)
  {
    return this.attrimatorsFor( attributes, function(attrimator) 
    {
      while (attrimator.next)
      {
        attrimator = attrimator.next;
      }
      
      attrimator.finish( this.frame );
    });
  },
  
  /**
   * Finishes all current attrimators for the specified attributes. Attribute 
   * names can be given as an array or a space separated string. If no 
   * attributes are given all attributes are assumed.
   *
   * @method finish
   * @param {String|Array} [attributes]
   * @chainable
   */
  finish: function(attributes)
  {
    return this.attrimatorsFor( attributes, function(attrimator)
    {
      attrimator.finish( this.frame );
    });
  },
  
  /**
   * Pauses all current attrimators for the specified attributes. Attribute 
   * names can be given as an array or a space separated string. If no 
   * attributes are given all attributes are assumed.
   *
   * @method pause
   * @param {String|Array} [attributes]
   * @chainable
   */
  pause: function(attributes)
  {
    return this.attrimatorsFor( attributes, function(attrimator)
    {
      attrimator.pause();
    });
  },
  
  /**
   * Resumes all current attrimators for the specified attributes. Attribute 
   * names can be given as an array or a space separated string. If no 
   * attributes are given all attributes are assumed.
   *
   * @method resume
   * @param {String|Array} [attributes]
   * @chainable
   */
  resume: function(attributes)
  {
    return this.attrimatorsFor( attributes, function(attrimator)
    {
      attrimator.resume();
    });
  },
  
  /**
   * Sets the given attributes to this Animator immediately.
   *
   * @method set
   * @param {Object} attributes
   * @chainable
   */
  set: function(attributes)
  {
    for (var attr in attributes)
    {
      this.frame[ attr ] = attributes[ attr ];
      this.updated[ attr ] = true;
    }
    
    this.apply();
    
    return this;
  },

  /**
   * Unsets the attribute, array of attributes, or object of attributes. 
   * Unsetting involves removing all attrimators and the current value in the 
   * frame,
   * 
   * @method unset
   * @param {String|Array|Object} attributes
   * @chainable
   */
  unset: function(attributes)
  {
    if ( anim8.isString( attributes ) )
    {
      this.attrimators.remove( attributes );
      delete this.frame[ attributes ];
    }
    else if ( anim8.isArray( attributes ) )
    {
      for (var i = 0; i &lt; attributes.length; i++)
      {
        this.unset( attributes[ i ] );
      }
    }
    else if ( anim8.isObject( attributes ) )
    {
      for (var attr in attributes)
      {
        this.unset( attr );
      }
    }

    return this;
  },
  
  /**
   * Gets the current attribute values for all attributes specified. The 
   * argument must be an object where the key is the name of an attribute.
   *
   * @method get
   * @param {Object} attributes
   * @return {Object}
   */
  get: function(attributes)
  {
    var out = {};
    
    for (var attr in attributes)
    {
      out[ attr ] = this.frame[ attr ];
    }
    
    return out;
  },

  /**
   * Returns the amount of finite time remaining before the animator is done
   * animating. Attrimators that don&#x27;t have a known end time are not included.
   * If there are no attrimators with end times then zero is returned.
   *
   * @method timeRemaining
   * @return {Number}
   */
  timeRemaining: function()
  {
    return this.attrimators.timeRemaining();
  },
  
  /**
   * Returns true if there are any attrimators on this Animator.
   *
   * @method hasAttrimators
   * @return {Boolean}
   */
  hasAttrimators: function()
  {
    return this.attrimators.size() &gt; 0;
  },
  
  /**
   * Returns the subject of the Animator optionally passing it through a wrapper
   * function before it&#x27;s returned.
   *
   * @method getSubject
   * @param {Function} [wrapper]
   * @return {any}
   */
  getSubject: function(wrapper)
  {
    var subject = this.subject;

    if ( anim8.isFunction( wrapper ) )
    {
      subject = wrapper( subject );
    }

    return subject;
  },

  /**
   * Invokes a function with the given context or the context of this Animator 
   * if none is given. This is particularly useful for having a function be 
   * called on deferred statements.
   * 
   * @method invoke
   * @param {Function} func
   * @param {Object} [context]
   * @param {Array} [args]
   * @chainable
   */
  invoke: function(func, context, args)
  {
    if ( anim8.isFunction( func ) )
    {
      func.apply( context || this, args || [] );
    }

    return this;
  },
  
  /**
   * Defers the method calls following this one to when the given event type 
   * (on or once) and event. To return this animator you need to call undefer() 
   * as many times as you called defer().
   *
   * @method defer
   * @param {String} eventType
   * @param {String} event
   * @param {Function} [callback]
   * @return {anim8.DeferAnimator}
   */
  defer: function(eventType, event, callback)
  {
    return new anim8.DeferAnimator( this, this, eventType, event, callback );
  },

  /**
   * Invokes the given callback when the last animation that was 
   * played/queued/transitioned starts.
   * 
   * @method onCycleStart
   * @param {Function} callback
   * @param {Object} [context]
   * @chainable
   */
  onCycleStart: function(callback, context)
  {
    this.once( &#x27;cycleStart:&#x27; + this.cycleNext, callback, context );

    return this;
  },

  /**
   * Invokes the given callback when the last animation that was
   * played/queued/transitioned ends.
   * 
   * @method onCycleEnd
   * @param {Function} callback
   * @param {Object} [context]
   * @chainable
   */
  onCycleEnd: function(callback, context)
  {
    this.once( &#x27;cycleEnd:&#x27; + this.cycleNext, callback, context );

    return this;
  }
  
};

/**
 * Adds the following event methods to Animators: on, once, off, trigger.
 */
anim8.eventize( anim8.Animator.prototype );

/**
 * Provides the ability to defer method calls until certain events are triggered.
 *
 * @class DeferAnimator
 * @constructor
 * @namespace anim8
 * @extends anim8.Defer
 */
anim8.DeferAnimator = function(animator, previous, eventType, event)
{
  this.$reset( animator, previous, eventType, event );
};

/**
 * Creates the Defer prototype for the following Animator methods.
 */
anim8.DeferAnimator.prototype = new anim8.Defer( anim8.DeferAnimator, 
[
  /**
   * Defers the {{#crossLink &quot;anim8.Animator/restore:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;restore&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/placeAttrimator:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;placeAttrimator&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/applyInitialState:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;applyInitialState&#x27;,

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/preupdate:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;preupdate&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/update:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;update&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/apply:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;apply&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/trimAttrimators:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   * @protected
   */
  &#x27;trimAttrimators&#x27;,

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/activate:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;activate&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/deactivate:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;deactivate&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/destroy:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;destroy&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/spring:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;spring&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/play:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;play&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/playAttrimators:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   * @protected
   */
  &#x27;playAttrimators&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/queue:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;queue&#x27;,

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/queueAttrimators:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   * @protected
   */
  &#x27;queueAttrimators&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/transition:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;transition&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/transitionAttrimators:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   * @protected
   */
  &#x27;transitionAttrimators&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/tween:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;tween&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/tweenTo:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;tweenTo&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/tweenMany:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;tweenMany&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/tweenManyTo:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;tweenManyTo&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/tweenFrom:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;tweenFrom&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/tweenManyFrom:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;tweenManyFrom&#x27;,

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/move:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;move&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/moveMany:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;moveMany&#x27;,

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/follow:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;follow&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/stop:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;stop&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/end:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;end&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/finish:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;finish&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/pause:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;pause&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/resume:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;resume&#x27;,

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/set:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;set&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/unset:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;unset&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/get:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;get&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/invoke:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;invoke&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/onCycleStart:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;onCycleStart&#x27;, 

  /**
   * Defers the {{#crossLink &quot;anim8.Animator/onCycleEnd:method&quot;}}{{/crossLink}} method until the deferred event has occurred.
   *
   * @method restore
   */
  &#x27;onCycleEnd&#x27;
]);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
